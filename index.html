<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>GEBER LIGHTING</title>
    <style>
    :root{
      --bg:#000;
      --panel:#07121a;
      --accent:#00d4ff;
      --muted:#9fb0c4;
      --btn:#0b3740;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#eaf6ff;font-family:Inter,system-ui,Arial,sans-serif}
    #app{display:flex;flex-direction:column;height:100vh;overflow:hidden}
    #stageWrap{flex:1;position:relative;background:#000;overflow:hidden;height:100vh;}
    canvas#stage{position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;touch-action:none}
    /* Panel */
    .panel{flex:0 0 auto;background:var(--panel);padding:10px;overflow-y:auto;max-height:44%;display:flex;flex-direction:column;gap:10px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .col{flex:1;display:flex;flex-direction:column}
    .label{font-size:12px;color:var(--muted);margin-bottom:4px}
    .small{font-size:12px;color:var(--muted);text-align:center}
    input[type=range]{width:100%}
    input[type=color]{appearance:none;border:none;padding:0;margin:0;width:44px;height:36px;border-radius:6px;cursor:pointer}
    button,select{padding:10px;border-radius:10px;border:none;background:var(--btn);color:#eaf6ff;font-weight:700;cursor:pointer}
    .bigBtn{background:linear-gradient(90deg,var(--accent),#006b7a);color:#001922;font-weight:900}
    .presetRow{display:flex;gap:6px;overflow-x:auto;padding-bottom:6px}
    .presetBox{background:#092023;padding:6px;border-radius:10px;display:flex;flex-direction:column;align-items:center;min-width:64px}
    .presetFader{height:120px;writing-mode:bt-lr;-webkit-appearance:slider-vertical}
    .fileRow{display:flex;gap:8px;align-items:center}
    .footer{text-align:center;font-size:11px;color:#7da;margin-top:6px}
    .smallBtn{padding:6px;border-radius:8px;background:#0e2b2f;font-weight:700}
    .controlGroup{display:flex;gap:6px;align-items:center}
    /* Grid for Strobe and Prisma Buttons */
    .strobe-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }
    .strobe-btn, .prisma-btn {
      padding: 6px 4px;
      border-radius: 6px;
      font-weight: 500;
      font-size: 11px;
      background: #0b3740;
    }
    .strobe-btn.active, .prisma-btn.active {
      background: var(--accent);
      color: var(--panel);
      font-weight: 700;
    }
    @media(min-width:920px){
      #app{flex-direction:row}
      #stageWrap{flex:1}
      .panel{width:420px;height:100vh;max-height:none;overflow:auto}
    }
    </style>
</head>
<body>
<!-- Pesan selamat datang -->
<div id="welcome" style="
  text-align:center;
  background:#000;
  color:#00d4ff;
  padding:10px;
  font-family:sans-serif;
  opacity:1;
  transition:opacity 1s ease;
">
  <b>GEBER LIGHTING V6</b><br>
  GTW MALES PENGEN BELI TRUCK
</div>
<script>
setTimeout(() => {
  const w = document.getElementById("welcome");
  w.style.opacity = "0";
  setTimeout(() => w.style.display = "none", 1000);
}, 3000);
</script>
<div id="app">
  <div id="stageWrap">
    <canvas id="stage" aria-label="Lighting Stage"></canvas>
  </div>
  <div class="panel" id="panel">
    <button id="powerBtn" class="bigBtn">POWER ON</button>
    <div class="row" style="margin-top:10px;">
      <button id="saveProjectBtn" class="smallBtn">Save Project</button>
      <input type="file" id="loadProjectInput" accept=".geber,.json" style="display:none">
      <button id="loadProjectBtn" class="smallBtn">Load Project</button>
    </div>
    <div class="row">
      <div class="col">
        <div class="label">Jumlah Beam</div>
        <input id="beamCount" type="range" min="2" max="50" step="2" value="8">
        <div class="small">Beams: <span id="beamCountLabel">8</span></div>
      </div>
      <div class="col">
        <div class="label">Dimmer</div>
        <input id="dimmer" type="range" min="0" max="100" value="95">
      </div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Beam Angle (¬∞)</div><input id="beamAngle" type="range" min="5" max="40" value="12"></div>
      <div class="col"><div class="label">Beam Range (px)</div><input id="beamRange" type="range" min="200" max="1600" value="900"></div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Global Warna</div><input id="globalColor" type="color" value="#ffffff"></div>
      <div class="col"><div class="label">Rainbow</div><button id="rainbowBtn">RAINBOW OFF</button></div>
      <div class="col"><div class="label">Gobo Aurora</div><button id="goboBtn">AURORA OFF</button></div>
    </div>
    <div class="row">
      <div class="col">
        <div class="label">Prisma Mode</div>
        <div id="prismaButtons" class="strobe-grid">
          <button data-mode="none" class="prisma-btn active">OFF</button>
          <button data-mode="split3" class="prisma-btn">1 (gobo1)</button>
          <button data-mode="split5" class="prisma-btn">2 (prisma 5)</button>
          <button data-mode="split7" class="prisma-btn">3 (kepyar)</button>
          <button data-mode="linear" class="prisma-btn">4 (Linear)</button>
          <button data-mode="combo" class="prisma-btn">5 (Combo)</button>
        </div>
      </div>
      <div class="col"><div class="label">Color </div><button id="crossColorBtn">Color OFF</button></div>
      <div class="col"><div class="label">Mini Brute</div><button id="miniBruteToggle">BRUTE OFF</button></div>
    </div>
    <div class="col">
  <div class="label">
    Strobe Mode
    <button id="toggleSpeedPanel" class="smallBtn" style="float:right;padding:4px 8px;font-size:10px;">Hide</button>
  </div>
  <div id="strobeButtons" class="strobe-grid">
    <button data-mode="off" class="strobe-btn active">OFF</button>
    <button data-mode="blink" class="strobe-btn">1</button>
    <button data-mode="flow" class="strobe-btn">2</button>
    <button data-mode="random" class="strobe-btn">3</button>
    <button data-mode="alternate" class="strobe-btn">4</button>
    <button data-mode="chase" class="strobe-btn">5</button>
    <button data-mode="converge" class="strobe-btn">6</button>
    <button data-mode="split" class="strobe-btn">7</button>
  </div>
</div>

<div class="col" id="strobeSpeedPanel">
  <div class="label">Strobe Speed (Hz)</div>
  <input id="strobeSpeed" type="range" min="1" max="80" value="14">
  <button id="saveStrobeSpeedBtn" class="smallBtn" style="margin-top:4px;">Save Speed</button>
  <div class="small">Saved per mode</div>
</div>
    <div><div class="label">Presets Gerakan (dorong 100% untuk aktif)</div><div class="presetRow" id="autoPresets"></div></div>
          <div class="col"><div class="label">Beam Speed</div><input id="presetSpeed" type="range" min="0.1" max="3" step="0.1" value="1"></div>
    <div style="margin-top:6px">
      <div class="label">Chase Recorder (5 slot)</div>
      <div class="row" id="chaseControls"></div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Mode</div><select id="modeSelect"><option value="auto">Auto</option><option value="manual">Manual</option></select></div>
      <div class="col"><div class="label">Manual Head</div><select id="manualHeadSelect"></select></div>
    </div>
    <div id="manualArea" style="display:none">
      <div class="label">Pan / Tilt</div>
      <div class="row"><input id="manualPan" type="range" min="-180" max="180" value="0"><input id="manualTilt" type="range" min="-60" max="10" value="-12"></div>
      <div class="label">Quick Colors</div>
      <div class="row" id="colorPresets">
        <button class="smallBtn" data-color="#ff0000" style="background:#ff0000;color:#000">R</button>
        <button class="smallBtn" data-color="#00ff00" style="background:#00ff00;color:#000">G</button>
        <button class="smallBtn" data-color="#0000ff" style="background:#0000ff;color:#fff">B</button>
        <button class="smallBtn" data-color="#ffffff" style="background:#fff;color:#000">W</button>
        <button class="smallBtn" data-color="#ffff00" style="background:#ffff00;color:#000">Y</button>
      </div>
      <div style="margin-top:8px"><input id="manualColor" type="color" value="#ffffff"></div>
      <div class="row" style="margin-top:8px">
        <button id="saveHeadA" class="smallBtn">Save‚ÜíA</button>
        <button id="loadHeadA" class="smallBtn">Load‚ÜêA</button>
        <button id="saveHeadB" class="smallBtn">Save‚ÜíB</button>
        <button id="loadHeadB" class="smallBtn">Load‚ÜêB</button>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="saveAll" class="smallBtn">Save All</button>
        <button id="loadAll" class="smallBtn">Load All</button>
        <button id="clearSlots" class="smallBtn">Clear</button>
      </div>
    </div>
<div class="label">Video Background (seting vidio tron di apk am</div>
<div class="fileRow">
  <input id="tronVideoFile" type="file" accept="image/*,video/*">
  <button id="playTron" class="smallBtn">Play Tron</button>
  <button id="pauseTron" class="smallBtn">Pause Tron</button>
  <button id="clearTron" class="smallBtn">Clear Tron</button>
  </div>
<div style="margin-top:6px">
  <div class="label">Martin Strobo Controls</div>
  <div class="row">
    <div class="col">
      <div class="label">Jumlah Martin Strobo</div>
      <input id="martinCount" type="range" min="0" max="20" step="1" value="2">
      <div class="small">Martins: <span id="martinCountLabel">2</span></div>
    </div>
    <div class="col">
      <div class="label">Spawn / Reset</div>
      <div class="controlGroup">
        <button id="spawnMartin" class="smallBtn">Spawn</button>
        <button id="clearMartin" class="smallBtn">Clear</button>
      </div>
    </div>
  </div>
</div>
<div style="margin-top:6px">
  <div class="label">Wallwasher Controls</div>
  <div class="row">
    <div class="col">
      <div class="label">Jumlah Wallwasher</div>
      <input id="wallCount" type="range" min="0" max="8" step="1" value="3">
      <div class="small">Wallwashers: <span id="wallCountLabel">3</span></div>
    </div>
    <div class="col">
      <div class="label">Spawn / Reset</div>
      <div class="controlGroup">
        <button id="spawnWall" class="smallBtn">Spawn</button>
        <button id="clearWall" class="smallBtn">Clear</button>
      </div>
    </div>
  </div>
</div>
<div style="margin-top:6px">
  <div class="label">ParLED Controls</div>
  <div class="row">
    <div class="col">
      <div class="label">Jumlah Parled</div>
      <input id="parCount" type="range" min="0" max="12" step="1" value="4">
      <div class="small">Parleds: <span id="parCountLabel">4</span></div>
    </div>
    <div class="col">
      <div class="label">Spawn / Reset</div>
      <div class="controlGroup">
        <button id="spawnPar" class="smallBtn">Spawn</button>
        <button id="clearPar" class="smallBtn">Clear</button>
      </div>
      <input type="range" min="1" max="8" value="4" id="miniBruteCount">
<button onclick="spawnMiniBrutes(parseInt(document.getElementById('miniBruteCount').value))">
  Spawn MiniBrute
</button>
    </div>
  </div>
</div>
<div class="row" style="margin-top:6px">
  <div class="col">
    <div class="label">Ukuran Martin Strobo</div>
    <input id="martinScale" type="range" min="0.5" max="2" step="0.1" value="1">
  </div>
  <div class="col">
    <div class="label">Rotasi Martin Strobo (¬∞)</div>
    <input id="martinRotate" type="range" min="-180" max="180" step="5" value="0">
  </div>
</div>
<div style="margin-top:8px" class="row">
  <div class="col">
    <div class="label">Ukuran Wallwasher</div>
    <input id="wallScale" type="range" min="0.5" max="2" step="0.1" value="1">
  </div>
  <div class="col">
    <div class="label">Rotasi Wallwasher (¬∞)</div>
    <input id="wallRotate" type="range" min="-180" max="180" step="5" value="0">
  </div>
<input type="color" id="goboColor1" value="#ff00ff">
<input type="color" id="goboColor2" value="#ffffff">
<input type="color" id="goboColor3" value="#ff66ff">
</div>
<button id="goboColorBtn">GOBO COLOR OFF</button>
<div class="label">Cross Color Custom</div>
<div class="row">
  <div class="col">
    <label>Warna 1</label>
    <input type="color" id="colorA" value="#ffffff">
  </div>
  <div class="col">
    <label>Warna 2</label>
    <input type="color" id="colorB" value="#b300ff">
  </div>
</div>
<div class="row" style="margin-top:5px;">
  <div class="col">
    <label>Speed (detik)</label>
    <input id="crossSpeed" type="range" min="0.2" max="5" step="0.1" value="1">
    <div class="small">Pergantian: <span id="crossSpeedLabel">1.0</span>s</div>
  </div>
 </div>
<div class="row" style="margin-top:6px">
  <div class="col">
    <div class="label">Warna Martin Strobo</div>
    <input id="martinColor" type="color" value="#ffffff" style="width:100%">
  </div>
  <div class="col">
    <div class="label">Mode Warna</div>
    <select id="martinColorMode" style="width:100%">
      <option value="global">Ikut Beam</option>
      <option value="custom">Custom</option>
    </select>
  </div>
</div>
<div class="footer">GEBER LIGHTING ‚Äî TEAM GEBER</div>
  </div>
</div>
<script>
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = Math.round(window.innerHeight * 0.6);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
const ui = {
  powerBtn: document.getElementById('powerBtn'),
  beamCount: document.getElementById('beamCount'),
  beamCountLabel: document.getElementById('beamCountLabel'),
  dimmer: document.getElementById('dimmer'),
  beamAngle: document.getElementById('beamAngle'),
  beamRange: document.getElementById('beamRange'),
  globalColor: document.getElementById('globalColor'),
  rainbowBtn: document.getElementById('rainbowBtn'),
  goboBtn: document.getElementById('goboBtn'),
  strobeSpeed: document.getElementById('strobeSpeed'),
  autoPresets: document.getElementById('autoPresets'),
  modeSelect: document.getElementById('modeSelect'),
  manualArea: document.getElementById('manualArea'),
  manualHeadSelect: document.getElementById('manualHeadSelect'),
  manualPan: document.getElementById('manualPan'),
  manualTilt: document.getElementById('manualTilt'),
  manualColor: document.getElementById('manualColor'),
  saveHeadA: document.getElementById('saveHeadA'),
  loadHeadA: document.getElementById('loadHeadA'),
  saveHeadB: document.getElementById('saveHeadB'),
  loadHeadB: document.getElementById('loadHeadB'),
  saveAll: document.getElementById('saveAll'),
  loadAll: document.getElementById('loadAll'),
  clearSlots: document.getElementById('clearSlots'),
  chaseControls: document.getElementById('chaseControls'),
  wallCount: document.getElementById('wallCount'),
  wallCountLabel: document.getElementById('wallCountLabel'),
  spawnWall: document.getElementById('spawnWall'),
  clearWall: document.getElementById('clearWall'),
  parCount: document.getElementById('parCount'),
  parCountLabel: document.getElementById('parCountLabel'),
  spawnPar: document.getElementById('spawnPar'),
  clearPar: document.getElementById('clearPar'),
  wallScale: document.getElementById('wallScale'),
  wallRotate: document.getElementById('wallRotate'),
  martinScale: document.getElementById('martinScale'),
  martinRotate: document.getElementById('martinRotate'),
  martinCount: document.getElementById("martinCount"),
  martinCountLabel: document.getElementById("martinCountLabel"),
  spawnMartin: document.getElementById("spawnMartin"),
  clearMartin: document.getElementById("clearMartin"),
  martinColor: document.getElementById("martinColor"),
  martinColorMode: document.getElementById("martinColorMode"),
  tronVideoFile: document.getElementById("tronVideoFile"),
  playTron: document.getElementById("playTron"),
  pauseTron: document.getElementById("pauseTron"),
  clearTron: document.getElementById("clearTron"),
  goboColorBtn: document.getElementById('goboColorBtn'),
  goboColor1: document.getElementById('goboColor1'),
  goboColor2: document.getElementById('goboColor2'),
  goboColor3: document.getElementById('goboColor3'),
  crossColorBtn: document.getElementById("crossColorBtn"),
  colorA: document.getElementById("colorA"),
  colorB: document.getElementById("colorB"),
  crossSpeed: document.getElementById("crossSpeed"),
  crossSpeedLabel: document.getElementById("crossSpeedLabel"),
  presetSpeed: document.getElementById('presetSpeed'),
  miniBruteToggle: document.getElementById('miniBruteToggle')
};
const PRESET_THRESHOLD = 95;
const SMOOTH = 0.12;
let strobeAccum = 0;
const state = {
  power: true,
  presetSpeed: 1.0,
  dimmer: Number(ui.dimmer ? ui.dimmer.value : 95)/100,
  angle: Number(ui.beamAngle ? ui.beamAngle.value : 12),
  range: Number(ui.beamRange ? ui.beamRange.value : 900),
  globalColor: ui.globalColor ? ui.globalColor.value : '#ffffff',
  rainbow: false,
  gobo: false,
  strobeMode: 'off',
  strobeSpeed: Number(ui.strobeSpeed ? ui.strobeSpeed.value : 14),
  prismaMode: 'none',
  prismaRotate: false,
  time: 0,
  presetActive: new Array(14).fill(false),
  heads: [],
  manualSelected: 0,
  miniBruteOn: false,
  bruteIntensity: 1.0,
  chases: [null,null,null,null,null],
  wallwashers: [],
  parleds: [],
  bgImageCanvas: null,
  miniBrutePos: { x: null, y: null },
  miniBrutes: [],
  martins: [],
  dragTarget: null,
  dragging: false,
  dragOffset: {x:0, y:0},
  selectedHead: null,
  selectedWall: null,
  selectedMartin: null,
  crossColor: false,
  goboColorFx: false,
  goboColors: ['#ff00ff', '#ffffff', '#ff66ff'],
  martinColorMode: 'global'
};
function withAlpha(color, alpha){
  if(!color) color = '#ffffff';
  color = String(color).trim();
  const hslMatch = color.match(/^hsl\(\s*([^\)]+)\s*\)$/i);
  if(hslMatch){ return `hsla(${hslMatch[1].trim()}, ${alpha})`; }
  if(/^hsla?\(/i.test(color) || /^rgba?\(/i.test(color)){
    const inner = color.replace(/^[^\(]+\(/,'').replace(/\)$/, '');
    const parts = inner.split(',').map(s=>s.trim());
    const baseParts = parts.slice(0,3).join(', ');
    if(/^hsl/i.test(color)){
      return `hsla(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
    } else {
      return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
    }
  }
  const rgbMatch = color.match(/^rgb\(\s*([^\)]+)\s*\)$/i);
  if(rgbMatch){ return `rgba(${rgbMatch[1].trim()}, ${alpha})`; }
  const hexMatch = color.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if(hexMatch){
    let hex = hexMatch[1];
    if(hex.length === 3) hex = hex.split('').map(ch=>ch+ch).join('');
    const r = parseInt(hex.slice(0,2),16);
    const g = parseInt(hex.slice(2,4),16);
    const b = parseInt(hex.slice(4,6),16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  return `rgba(255,255,255,${alpha})`;
}
function colorStop(color, a){ return withAlpha(color, a); }
function lerp(a,b,f){ return a + (b-a)*f; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function initHeads(count=8){
  ui.beamCountLabel.textContent = String(count);
  state.heads = [];
  const trY = Math.round(canvas.height * 0.12);
  const margin = Math.min(80, canvas.width * 0.06);
  const usable = canvas.width - margin*2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  for(let i=0;i<count;i++){
    const x = Math.round(margin + i*spacing);
    const pan = (i - (count-1)/2) * 8;
    const tilt = -12;
    state.heads.push({
      id: i, x, y: trY, pan, tilt, targetPan: pan, targetTilt: tilt,
      color: '#ffffff', intensity: state.dimmer, angle: state.angle, range: state.range, prismRotation: 0
    });
  }
  buildManualSelect();
  buildPresetsUI();
}
initHeads(Number(ui.beamCount ? ui.beamCount.value : 8));
function presetName(i){ 
  return ['Pargoy1','Pargoy2','Fan','Circle','SlowTilt','Circle2','Spiral','Pargoy terbaru','GTW','ZigZag','ZigZag2','Zigzag3','Circle3','circle4'][i] || `P${i+1}`; 
}
function buildPresetsUI(){
  ui.autoPresets.innerHTML = '';

  // Ambil mode terakhir dari localStorage (default 'slider')
  const presetMode = localStorage.getItem('presetMode') || 'slider';

  // ====== Tombol mode di pojok kanan atas ======
  const topBar = document.createElement('div');
  topBar.style.display = 'flex';
  topBar.style.justifyContent = 'flex-end';
  topBar.style.marginBottom = '6px';

  const modeBtn = document.createElement('button');
  modeBtn.textContent = presetMode === 'slider' ? 'Geser' : 'Tombo';
  modeBtn.className = 'smallBtn';
  modeBtn.style.padding = '3px 8px';
  modeBtn.style.fontSize = '10px';
  modeBtn.addEventListener('click', ()=>{
    const newMode = (localStorage.getItem('presetMode') === 'slider') ? 'button' : 'slider';
    localStorage.setItem('presetMode', newMode);
    buildPresetsUI(); // rebuild tampilan
  });

  topBar.appendChild(modeBtn);
  ui.autoPresets.appendChild(topBar);

  // ====== Container utama preset ======
  let container;
  if (presetMode === 'slider') {
    container = document.createElement('div');
    container.className = 'presetRow'; // gaya lama (scroll horizontal)
  } else {
    container = document.createElement('div');
    container.style.display = 'grid';
    container.style.gridTemplateColumns = 'repeat(auto-fill, minmax(70px, 1fr))';
    container.style.gridAutoFlow = 'column';
    container.style.gridTemplateRows = 'repeat(2, auto)';
    container.style.gap = '6px';
    container.style.overflowX = 'auto';
    container.style.paddingBottom = '6px';
    container.style.width = '100%';
    container.style.scrollbarWidth = 'thin';
  }

  // ====== Tentukan jumlah preset otomatis ======
  const totalPresets =
    (typeof state !== 'undefined' && state.presetActive)
      ? state.presetActive.length
      : (typeof presetName === 'function' ? 14 : 14);

  const buttons = []; // simpan semua tombol (untuk update warna)

  // ====== Buat semua preset ======
  for(let i=0;i<totalPresets;i++){
    const box = document.createElement('div');
    box.className = 'presetBox';
    box.style.minWidth = '64px';
    box.style.display = 'flex';
    box.style.flexDirection = 'column';
    box.style.alignItems = 'center';
    box.style.justifyContent = 'center';
    box.style.gap = '4px';

    const lbl = document.createElement('div');
    lbl.className = 'small';
    lbl.textContent = `P${i+1} ${presetName(i)}`;

    if (presetMode === 'slider') {
      // === MODE GESER 100% ===
      const f = document.createElement('input');
      f.type = 'range';
      f.min = 0; f.max = 100;
      f.value = state.presetActive[i] ? 100 : 0;
      f.dataset.id = i;
      f.className = 'presetFader';
      let userAdjusting = false;

f.addEventListener('pointerdown', () => userAdjusting = true);
f.addEventListener('pointerup', () => userAdjusting = false);

f.addEventListener('input', (e)=>{
  if (!userAdjusting) return; // ‚úÖ cegah auto-trigger
  const id = Number(e.target.dataset.id);
  const v = Number(e.target.value);
  const prev = state.presetActive[id];
  state.presetActive[id] = v >= PRESET_THRESHOLD;
  if(state.presetActive[id] && !prev) setStatus(`Preset ${id+1} ON`);
  if(!state.presetActive[id] && prev) setStatus(`Preset ${id+1} OFF`);
});
      box.appendChild(f);
    } else {
      // === MODE TOMBO (satu aktif, auto OFF lainnya) ===
      const b = document.createElement('button');
      b.textContent = state.presetActive[i] ? 'ON' : 'OFF';
      b.dataset.id = i;
      b.style.width = '65px';
      b.style.transition = 'background 0.2s';
      b.style.background = state.presetActive[i] ? '#d22' : '#0b3740';
      buttons.push(b);

      b.addEventListener('click', ()=>{
        const id = Number(b.dataset.id);
        const wasOn = state.presetActive[id];

        // Matikan semua preset
        for(let j=0;j<totalPresets;j++){
          state.presetActive[j] = false;
          buttons[j].textContent = 'OFF';
          buttons[j].style.background = '#0b3740';
        }

        // Aktifkan hanya yang diklik
        if(!wasOn){
          state.presetActive[id] = true;
          b.textContent = 'ON';
          b.style.background = '#d22';
          setStatus(`Preset ${id+1} ON`);
        } else {
          setStatus(`Preset ${id+1} OFF`);
        }
      });

      box.appendChild(b);
    }

    box.appendChild(lbl);
    container.appendChild(box);
  }

  ui.autoPresets.appendChild(container);
}
function buildManualSelect(){
  ui.manualHeadSelect.innerHTML = '';
  for(const h of state.heads){
    const o = document.createElement('option'); o.value = h.id; o.textContent = `Head ${h.id+1}`; ui.manualHeadSelect.appendChild(o);
  }
  ui.manualHeadSelect.value = state.manualSelected;
}
function updateManualControls(id){
  const h = state.heads.find(x=>x.id === Number(id));
  if(!h) return;
  ui.manualPan.value = Math.round(h.pan);
  ui.manualTilt.value = Math.round(h.tilt);
  ui.manualColor.value = h.color || '#ffffff';
}
function presetOffset(p, t, i) {
  const speed = state.presetSpeed || 1.0;
  const mid = (state.heads.length - 1) / 2;
  const dist = Math.abs(i - mid);
  switch (p) {
case 0: {
      // === Fokus ke tengah bawah bergantian ===
      const speed = (state.presetSpeed || 1.0) * 2.0; // agak cepat
      const total = state.heads.length;
      const mid = (total - 1) / 2;

      // siklus waktu setiap head bergantian
      const delay = i * 0.25; // beda fase antar beam
      const cycle = Math.sin(state.time * speed - delay);

      let pan, tilt;

      if (cycle < 0) {
        // === Saat ke bawah: fokus ke tengah ===
        const towardCenter = (i - mid) * -6; // hadap ke tengah
        pan = towardCenter;
        // makin negatif cycle, makin ke bawah
        tilt = 25 * Math.abs(cycle); // ke bawah tajam
      } else {
        // === Saat ke atas: arah normal ===
        pan = (i - mid) * 8;  // posisi biasa (lurus)
        tilt = -12 + cycle * -3; // ke atas normal
      }

      return { pan, tilt };
    }
    case 1: {
      const sp = 5.0;
      const pan = Math.sign(Math.sin(t * sp * speed + i * 0.4)) * 56;
      const tilt = -12 + Math.cos(t * 0.7 * speed + i * 0.3) * -4;
      return { pan, tilt };
    }
    case 2: {
      const spread = Math.sin(t * 0.7 * speed) * 26;
      const pan = (i - mid) * spread / ((state.heads.length / 2) || 1);
      const tilt = -10 + Math.cos(t * 0.9 * speed + i * 0.2) * -6;
      return { pan, tilt };
    }
    case 3: {
      const spd = 1.0 + dist * 0.04;
      const ang = t * 2.3 * spd * speed + i * (Math.PI * 2 / state.heads.length);
      return { pan: Math.sin(ang) * 28, tilt: -12 + Math.cos(ang) * 8 };
    }
    case 4: {
  // === Circle Outward (arah keluar semua, muter 1 arah) ===
  const speed = state.presetSpeed || 1.0;
  const total = state.heads.length;
  const baseTilt = -15; // sedikit ke atas biar realistis
  const time = state.time * 1.3 * speed;

  // sudut dasar tiap beam di lingkaran (arah tetap)
  const anglePerHead = (Math.PI * 2) / total;
  const rot = time; // rotasi lingkaran

  // radius lingkaran
  const radiusPan = 35;
  const radiusTilt = 20;

  // posisi beam di lingkaran yang berputar
  const ang = rot + i * anglePerHead;

  // posisi beam berpindah mengelilingi pusat
  const pan = Math.cos(ang) * radiusPan;
  const tilt = baseTilt + Math.sin(ang) * radiusTilt;

  // arah beam tetap ke luar dari pusat (tidak berubah arah)
  return { pan, tilt };
}
    case 5: {
      const s = 0.9 + (i % 3) * 0.25;
      const pan = Math.sin(t * 1.6 * s * speed + i * 0.3) * (10 + (i % 3) * 6);
      const tilt = -10 + Math.cos(t * 0.4 * speed + i * 0.3) * -8;
      return { pan, tilt };
    }
    case 6: {
      const spd = 1.4 * (1 + (1 - dist / (mid || 1)) * 0.7);
      const ang = t * spd * speed + i * 0.45;
      const radius = 6 + (mid - dist) * 3;
      return { pan: Math.sin(ang) * radius * 2.2, tilt: -12 + Math.sin(t * 1.6 * speed + i * 0.6) * -14 };
    }
    case 7: {
      const ampPan = 38;
      const ampTilt = 10;
      const panSpeed = 0.9 * speed;
      const tiltSpeed = 6.2 * speed;
      const panMod = 0.9 + 0.12 * Math.sin(t * 0.36 * speed);
      const pan = Math.sin(t * panSpeed) * ampPan * panMod;
      const tilt = -12 + Math.sin(t * tiltSpeed) * ampTilt;
      return { pan, tilt };
    }
    case 8: {
      const total = state.heads.length;
      const mid = (total - 1) / 2;
      const basePan = (i - mid) * 10;
      const upTilt = -12;
      const downTilt = 40;
      const speed = (state.presetSpeed && Number(state.presetSpeed)) || 1.0;
      const moveDur = 0.5 / speed;
      const waitAll = 0.6 / speed;
      const totalCycle = (moveDur * total * 2) + (waitAll * 2);
      let tt = (t * 1) % totalCycle;
      let pan = basePan;
      let tilt = upTilt;
      if (tt < moveDur * total + waitAll) {
        const start = i * moveDur;
        const end = start + moveDur;
        if (tt >= start && tt < end) {
          const f = (tt - start) / moveDur;
          tilt = lerp(upTilt, downTilt, f);
          pan = lerp(basePan, 0, f);
        } else if (tt >= end) {
          tilt = downTilt;
          pan = 0;
        } else {
          tilt = upTilt;
          pan = basePan;
        }
      }
      else {
        const tt2 = tt - (moveDur * total + waitAll);
        const start = i * moveDur;
        const end = start + moveDur;
        if (tt2 >= start && tt2 < end) {
          const f = (tt2 - start) / moveDur;
          tilt = lerp(downTilt, upTilt, f);
          pan = lerp(0, basePan, f);
        } else if (tt2 >= end) {
          tilt = upTilt;
          pan = basePan;
        } else {
          tilt = downTilt;
          pan = 0;
        }
      }
      return { pan, tilt };
    }
    case 9: {
      const speed = state.presetSpeed || 1.0;
      const panAmp = 40;
      const tiltAmp = 17;
      const panSpeed = 2.8 * speed;
      const tiltSpeed = 0.5 * speed;
      const phase = (i % 2 === 0) ? 0 : Math.PI;
      const pan = Math.sin(state.time * panSpeed + phase) * panAmp;
      const tilt = -12 + Math.sin(state.time * tiltSpeed) * tiltAmp;
      return { pan, tilt };
    }
    case 10: {
      const speed = state.presetSpeed || 1.0;
      const panAmp = 40;
      const tiltAmp = 20;
      const panSpeed = 0.5 * speed;
      const tiltSpeed = 2.8 * speed;
      const pan = Math.sin(state.time * panSpeed) * panAmp;
      const phase = (i % 2 === 0) ? 0 : Math.PI;
      const tilt = -12 + Math.sin(state.time * tiltSpeed + phase) * tiltAmp;
      return { pan, tilt };
    }
    case 11: {
      const speed = state.presetSpeed || 1.0;
      const panAmp = 40;
      const tiltAmp = 8;
      const panSpeed = 0.7 * speed;
      const tiltSpeed = 5.8 * speed;
      const pan = Math.sin(state.time * panSpeed) * panAmp;
      const phase = (i % 2 === 0) ? 0 : Math.PI;
      const tilt = -11 + Math.sin(state.time * tiltSpeed + phase) * tiltAmp;
      return { pan, tilt };
    }
    case 12: {
      const speed = state.presetSpeed || 1.0;
      const panAmp = 32;
      const tiltAmp = 40;
      const baseTilt = -12;
      const total = state.heads.length;
      const half = total / 2;
      const delayAmount = 0.35;
      const localIndex = (i < half) ? i : (i - half);
      const dir = (i < half) ? 1 : -1;
      const delay = localIndex * delayAmount;
      const swing = Math.sin(state.time * 0.6 * speed);
      const ang = dir * swing * Math.PI - delay;
      const pan = Math.sin(ang) * panAmp;
      const tilt = baseTilt + Math.cos(ang) * tiltAmp;
      return { pan, tilt };
    }
    case 5: {
  const speed = state.presetSpeed || 1.0;

  // rotasi waktu
  const rot = t * 1.8 * speed;

  let pan;
  let tilt;

  if (i < 2) {
    // BEAM 1 & 2 ‚Üí MUTER KE KANAN
    const ang = rot + i * 0.3;
    pan = Math.cos(ang) * 40;   // besar muter
    tilt = -12 + Math.sin(ang) * 12;
  } else {
    // BEAM 3 & 4 ‚Üí MUTER KE KIRI
    const ang = -rot + i * 0.3;
    pan = Math.cos(ang) * 40;
    tilt = -12 + Math.sin(ang) * 12;
  }

  return { pan, tilt };
}
    case 14: {
  const speed = state.presetSpeed || 1.0;

  // rotasi waktu
  const rot = t * 1.8 * speed;

  let pan;
  let tilt;

  if (i < 2) {
    // BEAM 1 & 2 ‚Üí MUTER KE KANAN
    const ang = rot + i * 0.3;
    pan = Math.cos(ang) * 40;   // besar muter
    tilt = -12 + Math.sin(ang) * 12;
  } else {
    // BEAM 3 & 4 ‚Üí MUTER KE KIRI
    const ang = -rot + i * 0.3;
    pan = Math.cos(ang) * 40;
    tilt = -12 + Math.sin(ang) * 12;
  }

  return { pan, tilt };
    }
  }
}

function drawBackground(){
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  if(state.bgImageCanvas){
    const size = canvas.width;
    const yoffset = Math.max(0, Math.round((canvas.height - size) / 2));
    ctx.drawImage(state.bgImageCanvas, 0, 0, state.bgImageCanvas.width, state.bgImageCanvas.height, 0, yoffset, canvas.width, size);
    ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fillRect(0, yoffset, canvas.width, size);
  }
  ctx.fillStyle = '#041017'; ctx.fillRect(0, canvas.height*0.82, canvas.width, canvas.height*0.18);
  const tY = canvas.height*0.12; ctx.fillStyle = '#111217'; ctx.fillRect(0, tY-10, canvas.width, 14);
}
function drawHeadMounts(){
  const trY = canvas.height*0.12;
  for(const h of state.heads){
    ctx.fillStyle = '#23282c'; ctx.fillRect(h.x-12, trY-26, 24, 12);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.strokeRect(h.x-12, trY-26, 24, 12);
  }
}
function drawHeadMarkers(){
  for(const h of state.heads){
    ctx.beginPath(); ctx.arc(h.x,h.y,12,0,Math.PI*2); ctx.fillStyle='#0b0e11'; ctx.fill();
    const fillColor = state.rainbow ? `hsl(${Math.round((state.time*60 + h.id*28) % 360)},100%,60%)` : (h.color || state.globalColor || '#9fb0c4');
    ctx.beginPath(); ctx.arc(h.x,h.y,6,0,Math.PI*2); ctx.fillStyle = fillColor; ctx.fill();
    if(state.selectedHead === h.id){ ctx.strokeStyle='rgba(0,212,255,0.95)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(h.x,h.y,18,0,Math.PI*2); ctx.stroke(); }
  }
}
function computeEndpoint(h, panDeg, tiltDeg, scale, angleDeg){
  const pR = panDeg * Math.PI/180;
  const tR = tiltDeg * Math.PI/180;
  const dx = Math.sin(pR) * Math.cos(tR); 
  const dy = -Math.sin(tR);
  const dz = Math.cos(pR) * Math.cos(tR); 
  const lenBase = Number(h.range || state.range);
  const len = lenBase * scale * (1 - Math.abs(Math.sin(tR)) * 0.18); 
  const endX = h.x + dx * len;
  const endY = h.y + dy * len;
  const spread = Math.tan(angleDeg * Math.PI/180) * len;
  return { endX, endY, spread };
}
function drawBeam(h){
  if(state.miniBruteOn) return;
  const baseX = h.x, baseY = h.y;
  const angle = h.angle || state.angle;
  const layers = [
    {scale:0.92,alpha:1.0},
    {scale:1.12,alpha:0.36},
    {scale:1.45,alpha:0.12},
    {scale:1.9,alpha:0.06}
  ];
  const computedColor = state.rainbow
    ? `hsl(${Math.round((state.time * 60 + h.id*28) % 360)},100%,60%)`
    : (h.color || state.globalColor || '#ffffff');
   // === fungsi pembuat beam utama ===
  function drawCone(scale, alpha, panOffset=0){
    const e = computeEndpoint(h, h.pan + panOffset, h.tilt, scale, angle);
    const grad = ctx.createLinearGradient(baseX, baseY, e.endX, e.endY);
    if (state.goboColorFx) {
      const c1 = state.goboColors[0];
      const c2 = state.goboColors[1];
      const c3 = state.goboColors[2];
      // ‚ö†Ô∏è TANPA ANIMASI PERGESERAN ‚Äî gunakan posisi tetap
      grad.addColorStop(0.0, colorStop(c1, state.dimmer * alpha));
      grad.addColorStop(0.25, colorStop(c2, state.dimmer * alpha));
      grad.addColorStop(0.55, colorStop(c3, state.dimmer * alpha));
      grad.addColorStop(0.85, 'rgba(0,0,0,0)');
    } else {
      grad.addColorStop(0, colorStop(computedColor, state.dimmer * alpha));
      grad.addColorStop(0.5, colorStop(computedColor, state.dimmer * alpha * 0.12));
      grad.addColorStop(1, 'rgba(0,0,0,0)');
    }
    ctx.beginPath();
    ctx.moveTo(baseX, baseY);
    ctx.lineTo(e.endX - e.spread * 0.6, e.endY);
    ctx.lineTo(e.endX + e.spread * 0.6, e.endY);
    ctx.closePath();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
  drawCone(layers[0].scale, layers[0].alpha);
  const pm = state.prismaMode;
  if(pm.startsWith('split')){
    const n = Number(pm.replace('split','')) || 3;
    const spreadDeg = 14;
    const rot = state.prismaRotate ? (h.prismRotation || 0) : 0;
    for(let k=0;k<n;k++){
      const frac = n===1?0.5:k/(n-1);
      const offDeg = (frac - 0.5) * spreadDeg + rot;
      drawCone(1.06, 0.28, offDeg);
    }
    drawCone(1.12, 0.22);
    drawCone(1.45, 0.08);
  } else if(pm === 'linear'){
    for(let k=0;k<4;k++){
      const off = (k - (4-1)/2) * 10;
      drawCone(1 + Math.abs(off)/50, 0.26, off);
    }
  } else if(pm === 'combo'){
    for(let k=0;k<3;k++) drawCone(1 + k*0.06, 0.22);
    const rot = state.prismaRotate ? (h.prismRotation || 0) : 0;
    for(let p=0;p<4;p++) drawCone(1.1 + p*0.05, 0.16, rot + p*2);
  }
  drawCone(layers[3].scale, layers[3].alpha);
  if(state.gobo){
    const e = computeEndpoint(h, h.pan, h.tilt, 0.85, angle);
    ctx.save();
    ctx.globalAlpha = 0.28 * state.dimmer;
    ctx.translate(e.endX, e.endY);
    ctx.rotate((state.time*0.4 + h.id*0.35) % (Math.PI*2));
    const aur = ctx.createRadialGradient(0,0,0,0,0,
      Math.max(60, Math.tan(angle * Math.PI/180) * (h.range||state.range) * 0.55));
    aur.addColorStop(0, 'rgba(120,220,255,0.45)');
    aur.addColorStop(0.45, 'rgba(220,120,255,0.28)');
    aur.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = aur;
    ctx.beginPath();
    ctx.ellipse(0,0,(h.range||state.range)*0.06,(h.range||state.range)*0.04,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  const ep = computeEndpoint(h, h.pan, h.tilt, 0.95, angle);
  const radius = 10 + (h.intensity||1) * 8;
  const spotGrad = ctx.createRadialGradient(ep.endX, ep.endY, 0, ep.endX, ep.endY, radius);
  spotGrad.addColorStop(0, colorStop(computedColor, 0.36 * state.dimmer));
  spotGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = spotGrad;
  ctx.fillRect(ep.endX - radius, ep.endY - radius, radius*2, radius*2);
  ctx.globalCompositeOperation = 'source-over';
}
function drawMiniBrutes(){
  // Jika tidak ada Mini Brute, berhenti.
  if(state.miniBrutes.length === 0) return;

  // --- PARAMETER UKURAN MINI BRUTE ---
  const baseScale = 0.75; 
  const bulbDiameter = 10; 
  const bulbRadius = bulbDiameter / 2;
  const frameThickness = 2; 
  const innerGap = 5; 
  const outerPadding = 4; 
  // -----------------------------------------------------------------

  for(let i=0; i<state.miniBrutes.length; i++){
    const mb = state.miniBrutes[i];
    const scale = (mb.scale || 1) * baseScale; 
    
    // ... [Posisi dan perhitungan ukuran fixture] ...
    const mx = mb.x;
    const my = mb.y;
    const totalBulbWidth = (bulbDiameter * 2) + innerGap + (frameThickness * 4);
    const fixtureInnerSize = totalBulbWidth + outerPadding * 2;
    const hw = (fixtureInnerSize / 2) * scale;
    const hh = (fixtureInnerSize / 2) * scale;

    ctx.save();
    ctx.translate(mx, my);
    ctx.rotate((mb.rotation||0) * Math.PI/180);
    
    // --- GAMBAR FISIK FIXTURE (KOTAK HITAM) ---
    ctx.fillStyle = '#111217'; 
    ctx.fillRect(-hw, -hh, hw*2, hh*2); 
    ctx.strokeStyle = '#23282c'; 
    ctx.lineWidth = 1 * scale;
    ctx.strokeRect(-hw, -hh, hw*2, hh*2);
    
    // ... [Perhitungan Offset dan Unit Lampu] ...
    const totalInnerWidth = (bulbDiameter * 2) + innerGap + (frameThickness * 4);
    const startXOffset = (-totalInnerWidth / 2) * scale; 
    const startYOffset = (-totalInnerWidth / 2) * scale; 
    const stepUnit = (bulbDiameter + innerGap + frameThickness * 2) * scale;
    const bulbUnitRadius = bulbRadius * scale;
    const frameUnitThickness = frameThickness * scale;
    const cobUnitRadius = bulbUnitRadius * 0.3;

    // =======================================================
    // üî¥ LOGIKA ANIMASI FADE-IN/FADE-OUT
    // =======================================================
    // 1. Tentukan Target Intensitas (0 saat mati, state.dimmer saat menyala)
    const TARGET_INTENSITY = state.miniBruteOn ? state.dimmer : 0;
    const FADE_RATE = 0.1; // Kecepatan Fade (0.05 = medium, 0.1 = cepat, 0.01 = sangat lambat)

    // 2. Inisialisasi variabel fadeIntensity jika belum ada
    if (mb.fadeIntensity === undefined) {
        mb.fadeIntensity = TARGET_INTENSITY;
    }
    
    // 3. Gerakkan mb.fadeIntensity menuju TARGET_INTENSITY (Animasi)
    if (mb.fadeIntensity < TARGET_INTENSITY) {
        mb.fadeIntensity = Math.min(TARGET_INTENSITY, mb.fadeIntensity + FADE_RATE); // Menerang (Fade-In)
    } else if (mb.fadeIntensity > TARGET_INTENSITY) {
        mb.fadeIntensity = Math.max(TARGET_INTENSITY, mb.fadeIntensity - FADE_RATE); // Meredup (Fade-Out)
    }
    
    const currentIntensity = mb.fadeIntensity; // Intensitas yang sedang dianimasikan
    const strobeOn = strobeVisible(1000 + i); 
    
    // Lampu hanya terlihat jika intensitas > ambang batas (0.01) DAN Strobe sedang ON
    const visible = currentIntensity > 0.01 && strobeOn; 
    // =======================================================

    // === Loop untuk 4 lampu Mini Brute ===
    for(let r=0; r<2; r++){ 
      for(let c=0; c<2; c++){ 
        const lampCenterX = startXOffset + c * stepUnit + bulbUnitRadius + frameUnitThickness;
        const lampCenterY = startYOffset + r * stepUnit + bulbUnitRadius + frameUnitThickness;
        
        // --- GAMBAR BINGKAI DAN REFLEKTOR ---
        ctx.fillStyle = '#23282c'; 
        ctx.fillRect(lampCenterX - bulbUnitRadius - frameUnitThickness, 
                     lampCenterY - bulbUnitRadius - frameUnitThickness, 
                     bulbUnitRadius * 2 + frameUnitThickness * 2, 
                     bulbUnitRadius * 2 + frameUnitThickness * 2);
        
        ctx.beginPath();
        ctx.arc(lampCenterX, lampCenterY, bulbUnitRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#cccccc'; 
        ctx.fill();
        
        const reflectorGradient = ctx.createRadialGradient(lampCenterX, lampCenterY, bulbUnitRadius * 0.7, lampCenterX, lampCenterY, bulbUnitRadius);
        reflectorGradient.addColorStop(0, '#ffffff'); 
        reflectorGradient.addColorStop(1, '#999999'); 
        ctx.fillStyle = reflectorGradient;
        ctx.fill();


        // --- GAMBAR COB LED KUNING DI TENGAH REFLEKTOR (Fading) ---
        ctx.beginPath();
        ctx.arc(lampCenterX, lampCenterY, cobUnitRadius, 0, Math.PI * 2);
        
        // Opasitas COB LED bergantung pada currentIntensity
        if (currentIntensity > 0.01) {
            ctx.fillStyle = `rgba(255, 200, 0, ${currentIntensity * 0.9})`; 
        } else {
            ctx.fillStyle = 'rgba(80,60,0,0.5)'; // Redup/coklat saat mati
        }
        ctx.fill();
        
        // --- EFEK CAHAYA (Fading) ---
        if(visible){
          const spreadMultiplier = 8; 
          const maxLightRadius = bulbDiameter * scale * spreadMultiplier; 

          const intensity = currentIntensity; // Gunakan intensitas animasi

          const g = ctx.createRadialGradient(lampCenterX, lampCenterY, 0, lampCenterX, lampCenterY, maxLightRadius);
          
          // Semua stop gradient menggunakan 'intensity' yang sedang dianimasikan
          g.addColorStop(0.0, `rgba(255, 255, 255, ${intensity * 1.0})`); 
          g.addColorStop(0.05, `rgba(255, 255, 220, ${intensity * 0.8})`); 
          g.addColorStop(0.2, `rgba(255, 240, 200, ${intensity * 0.1})`); 
          g.addColorStop(1.0, 'rgba(0,0,0,0)'); 

          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(lampCenterX, lampCenterY, maxLightRadius, 0, Math.PI * 2); 
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
      }
    }
    ctx.restore();
  }
}

function strobeVisible(index){
  const mode = state.strobeMode;
  const speed = clamp(Number(state.strobeSpeed), 0.5, 200);
  if(mode === 'off' || !state.power) return true;
  if(mode === 'blink') return Math.floor(strobeAccum * speed) % 2 === 0;
  if(mode === 'flow'){ const phase = (strobeAccum * speed * 2 * Math.PI) + (index * 0.6); return Math.sin(phase) > 0; }
  if(mode === 'random'){ const v = Math.sin((strobeAccum * speed * 3.14) + index * 7.13); return v > Math.cos(index * 0.3); }
  const totalHeads = state.heads.length;
  if(mode === 'alternate'){
    const group = index % 2;
    const timeStep = Math.floor(strobeAccum * speed);
    return timeStep % 2 === group;
  }
  if(mode === 'chase'){
    const timeStep = Math.floor(strobeAccum * speed * 2) % totalHeads;
    return index === timeStep;
  }
  if(mode === 'converge'){
    const midPoint = Math.floor(totalHeads / 2);
    const timeStep = Math.floor(strobeAccum * speed * 2) % midPoint;
    return index === timeStep || index === (totalHeads - 1 - timeStep);
  }
  if (mode === 'split') {
    const half = Math.floor(totalHeads / 2);
    const phase = Math.floor(strobeAccum * speed * 2) % 2;
    if (phase === 0) return index < half;
    else return index >= half;
  }
  return true;
}
function spawnWallwashers(count){
  state.wallwashers = [];
  const margin = 40;
  const usable = canvas.width - margin*2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const baseY = Math.round(canvas.height * 0.55);
  for(let i=0;i<count;i++){
    const x = Math.round(margin + i*spacing);
    const w = { id:i, x, y: baseY, rotation:0, scale:1, ledCount: 12, color: '#ffffff', intensity: state.dimmer };
    state.wallwashers.push(w);
  }
  saveStateUI();
}
function drawWallwashers(){
  for(let i=0;i<state.wallwashers.length;i++){
    const w = state.wallwashers[i];
    const barH = Math.round(canvas.height * 0.36);
    const barW = Math.max(18, Math.round(canvas.width * 0.02));
    const top = w.y - Math.round(barH/2);
    ctx.save();
    ctx.translate(w.x, top + barH/2);
    ctx.rotate((w.rotation||0) * Math.PI/180);
    ctx.scale(w.scale || 1, w.scale || 1);
    ctx.fillStyle = '#0b0f11'; ctx.fillRect(-Math.round(barW/2), -Math.round(barH/2), barW, barH);
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.strokeRect(-Math.round(barW/2), -Math.round(barH/2), barW, barH);
    const ledCols = 2;
    const ledRows = w.ledCount || 12;
    const gap = Math.round((barH - ledRows*8) / Math.max(1, ledRows));
    for(let r=0;r<ledRows;r++){
      const ly = -Math.round(barH/2) + gap/2 + r*(8 + gap) + 8;
      const lx = -Math.round(barW/2) + 8;
      const visible = strobeVisible(i*3 + r);
      const alpha = visible ? clamp(w.intensity, 0.08, 1) : 0.04;
      const ledColor = state.rainbow ? `hsl(${Math.round((state.time*60 + i*22 + r*6) % 360)},100%,60%)` : (w.color || state.globalColor || '#ffffff');
      ctx.beginPath(); ctx.arc(lx, ly, 5, 0, Math.PI*2); ctx.fillStyle = withAlpha(ledColor, alpha); ctx.fill();
      ctx.beginPath(); ctx.arc(lx, ly, 2, 0, Math.PI*2); ctx.fillStyle = withAlpha('#fff', alpha*0.9); ctx.fill();
    }
    const stripW = Math.round(barW * 0.36);
    const stripX = Math.round(barW/2) - stripW - 6;
    const stripGrad = ctx.createLinearGradient(stripX - barW/2, -barH/2, stripX - barW/2, barH/2);
    const color = state.rainbow ? `hsl(${Math.round((state.time*60 + i*40) % 360)},100%,60%)` : (w.color || state.globalColor || '#fff');
    stripGrad.addColorStop(0, withAlpha(color, 0.8 * w.intensity));
    stripGrad.addColorStop(0.5, withAlpha(color, 0.28 * w.intensity));
    stripGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = stripGrad;
    ctx.fillRect(stripX - barW/2, -Math.round(barH/3), stripW, Math.round(barH*2/3));
    ctx.restore();
  }
}
function spawnParleds(count){
  state.parleds = [];
  const margin = 40;
  const usable = canvas.width - margin*2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const baseY = Math.round(canvas.height * 0.72);
  for(let i=0;i<count;i++){
    const x = Math.round(margin + i*spacing);
    const p = { id:i, x, y: baseY, ledCount: 7, color: '#ffffff', intensity: state.dimmer };
    state.parleds.push(p);
  }
  saveStateUI();
}
function spawnMiniBrutes(count){
  state.miniBrutes = [];
  const margin = 40;
  const usable = canvas.width - margin * 2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const y = Math.round(canvas.height * 0.25);
  for (let i = 0; i < count; i++) {
    state.miniBrutes.push({
      id: i,
      x: Math.round(margin + i * spacing),
      y: y,
      intensity: 1.0
    });
  }
  saveStateUI();
}
function drawParleds(){
  for(let i=0;i<state.parleds.length;i++){
    const p = state.parleds[i];
    const radius = Math.max(18, Math.round(canvas.width * 0.03));
    ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI*2); ctx.fillStyle = '#0b0f10'; ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.stroke();
    const n = p.ledCount || 7;
    for(let k=0;k<n;k++){
      const ang = (k / n) * Math.PI*2 - Math.PI/2;
      const lx = p.x + Math.cos(ang) * (radius*0.6);
      const ly = p.y + Math.sin(ang) * (radius*0.6);
      const visible = strobeVisible(200 + i*7 + k);
      const alpha = visible ? clamp(p.intensity, 0.08, 1) : 0.05;
      const ledColor = state.rainbow ? `hsl(${Math.round((state.time*60 + i*28 + k*8) % 360)},100%,60%)` : (p.color || state.globalColor || '#ffffff');
      const g = ctx.createRadialGradient(lx,ly,0,lx,ly,8);
      g.addColorStop(0, withAlpha('#fff', alpha));
      g.addColorStop(0.2, withAlpha(ledColor, alpha));
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(lx, ly, 6, 0, Math.PI*2); ctx.fill();
    }
  }
}
function spawnMartins(count) {
  state.martins = [];
  const margin = 40;
  const usable = canvas.width - margin * 2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const y = Math.round(canvas.height * 0.30);
  for (let i = 0; i < count; i++) {
    state.martins.push({
      id: i,
      x: Math.round(margin + i * spacing),
      y: y,
      rotation: 0,
      scale: 1,
      color: "#ffffff",
      intensity: 1.0
    });
  }
  saveStateUI();
}
const martinVideo = document.createElement("video");
martinVideo.src = "./martin.mp4";
martinVideo.loop = true;
martinVideo.muted = true;
martinVideo.playsInline= true;
martinVideo.autoplay = true;
martinVideo.play();
function drawMartins() {
  if (!state.martins) return;
  const baseSize = Math.min(100, Math.round(canvas.width * 0.12));
  for (let i = 0; i < state.martins.length; i++) {
    const m = state.martins[i];
    const visible = strobeVisible(300 + i);
    const w = baseSize * 1.6 * (m.scale || 1);
    const h = baseSize * 1.0 * (m.scale || 1);
    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate((m.rotation || 0) * Math.PI / 180);
    ctx.fillStyle = "#111";
    ctx.fillRect(-w / 2, -h / 2, w, h);
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    ctx.strokeRect(-w / 2, -h / 2, w, h);
    if (visible && state.power) {
      try {
        ctx.drawImage(martinVideo, -w / 2, -h / 2, w, h);
      } catch (err) {}
    }
    ctx.restore();
  }
}
canvas.addEventListener('pointerdown', (e)=>{
  const r = canvas.getBoundingClientRect();
  const px = e.clientX - r.left, py = e.clientY - r.top;
  let nearest = -1, nd = 1e9;
  for(const h of state.heads){
    const d = Math.hypot(px - h.x, py - h.y);
    if(d < 30 && d < nd){ nd=d; nearest=h.id; }
  }
  if(nearest >= 0){
    state.selectedHead = nearest;
    state.dragging = true;
    state.dragTarget = {type:'head', id:nearest};
    const hh = state.heads.find(x=>x.id===nearest);
    state.dragOffset = { x: px - hh.x, y: py - hh.y };
    ui.manualHeadSelect.value = nearest;
    updateManualControls(nearest);
    setStatus('Selected Head '+(nearest+1),700);
    return;
  }
  for(const w of state.wallwashers){
    const barH = Math.round(canvas.height * 0.36);
    const barW = Math.max(18, Math.round(canvas.width * 0.02));
    const left = w.x - Math.round(barW/2);
    const top = w.y - Math.round(barH/2);
    if(px >= left - 8 && px <= left + barW + 8 && py >= top - 8 && py <= top + barH + 8){
      state.dragging = true;
      state.dragTarget = {type:'wall', id: w.id};
      state.dragOffset = { x: px - w.x, y: py - w.y };
      state.selectedWall = w.id;
      ui.wallScale.value = w.scale || 1;
      ui.wallRotate.value = w.rotation || 0;
      setStatus('Selected Wallwasher '+(w.id+1),700);
      return;
    }
  }
  for(const p of state.parleds){
    const radius = Math.max(18, Math.round(canvas.width * 0.03));
    const d = Math.hypot(px - p.x, py - p.y);
    if(d < radius + 8){
      state.dragging = true;
      state.dragTarget = {type:'par', id: p.id};
      state.dragOffset = { x: px - p.x, y: py - p.y };
      setStatus('Selected ParLED '+(p.id+1),700);
      return;
    }
  }
  for(const mb of (state.miniBrutes || [])){
    const size = Math.min(64, Math.round(canvas.width * 0.06));
    const hw = size * 1.6, hh = size * 0.95;
    const hx = mb.x - Math.round(hw/2), hy = mb.y - Math.round(hh/2);
    if(px >= hx && px <= hx + hw && py >= hy && py <= hy + hh){
      state.dragging = true;
      state.dragTarget = {type:'miniBrute', id: mb.id};
      state.dragOffset = { x: px - mb.x, y: py - mb.y };
      setStatus('Selected MiniBrute '+(mb.id+1),700);
      return;
    }
  }
  for (const m of (state.martins || [])) {
    const size = Math.min(100, Math.round(canvas.width * 0.12));
    const w = size * 1.6 * (m.scale || 1);
    const h = size * 1.0 * (m.scale || 1);
    const hx = m.x - w / 2, hy = m.y - h / 2;
    if (px >= hx && px <= hx + w && py >= hy && py <= hy + h) {
      state.dragging = true;
      state.dragTarget = { type: "martin", id: m.id };
      state.dragOffset = { x: px - m.x, y: py - m.y };
      state.selectedMartin = m.id;
      ui.martinScale.value = m.scale || 1;
      ui.martinRotate.value = m.rotation || 0;
      ui.martinColor.value = m.color || "#ffffff";
      setStatus("Selected Martin " + (m.id + 1), 700);
      return;
    }
  }
});
canvas.addEventListener('pointermove', (e)=>{
  if(!state.dragging || !state.dragTarget) return;
  const r = canvas.getBoundingClientRect();
  const px = e.clientX - r.left, py = e.clientY - r.top;
  const t = state.dragTarget;
  if(t.type === 'head'){
    const h = state.heads.find(x=>x.id === t.id);
    if(h){
      h.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      h.y = Math.max(10, Math.min(canvas.height - 10, Math.round(py - state.dragOffset.y)));
    }
  } 
  else if(t.type === 'wall'){
    const w = state.wallwashers.find(x=>x.id === t.id);
    if(w){
      w.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      w.y = Math.max(60, Math.min(canvas.height * 0.85, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  } 
  else if(t.type === 'par'){
    const p = state.parleds.find(x=>x.id === t.id);
    if(p){
      p.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      p.y = Math.max(40, Math.min(canvas.height * 0.9, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  } 
  else if(t.type === 'miniBrute'){
    const mb = state.miniBrutes.find(x=>x.id === t.id);
    if(mb){
      mb.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      mb.y = Math.max(20, Math.min(canvas.height - 20, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  }
  else if(t.type === 'martin'){
    const m = state.martins.find(x=>x.id === t.id);
    if(m){
      m.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      m.y = Math.max(20, Math.min(canvas.height - 20, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  }
});
canvas.addEventListener('pointerup', ()=>{
  state.dragging = false;
  state.dragTarget = null;
});
const STORAGE_KEY = 'geber_light_fix_v2';
function loadStorage(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }catch(e){ return {}; } }
function saveStorage(obj){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); setStatus('Saved',900);}catch(e){ setStatus('Storage failed',900);} }
function saveStateUI(){
  const st = loadStorage();
  st.wallwashers = state.wallwashers;
  st.parleds = state.parleds;
  st.miniBrutes = state.miniBrutes;
  saveStorage(st);
}
function restoreStateUI(){
  const st = loadStorage();
  if(st.wallwashers) state.wallwashers = st.wallwashers;
  if(st.parleds) state.parleds = st.parleds;
  if(st.miniBrutes) state.miniBrutes = st.miniBrutes;
}
restoreStateUI();
function createChaseUI(){
  ui.chaseControls.innerHTML = '';
  for(let i=0;i<6;i++){
    const w = document.createElement('div'); w.style.display='flex'; w.style.flexDirection='column'; w.style.gap='6px';
    const t = document.createElement('div'); t.className='small'; t.textContent='Chase '+(i+1);
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='6px';
    const rec = document.createElement('button'); rec.textContent='REC'; rec.dataset.slot=i; rec.style.background='#8b1a1a';
    const play = document.createElement('button'); play.textContent='PLAY'; play.dataset.slot=i;
    const clr = document.createElement('button'); clr.textContent='CLEAR'; clr.dataset.slot=i;
    row.appendChild(rec); row.appendChild(play); row.appendChild(clr);
    w.appendChild(t); w.appendChild(row); ui.chaseControls.appendChild(w);
    let recorder = null;
    rec.addEventListener('click', ()=>{
      const s = Number(rec.dataset.slot);
      if(rec.dataset.rec === '1'){ rec.dataset.rec='0'; rec.style.background=''; if(recorder){ recorder.stop(); recorder=null; setStatus('Recording stopped',900); } }
      else { rec.dataset.rec='1'; rec.style.background='#d33'; recorder = startRecorder(s, rec); setStatus('Recording chase '+(s+1),900); }
    });
    play.addEventListener('click', ()=> playChaseSlot(Number(play.dataset.slot)));
    clr.addEventListener('click', ()=> clearChaseSlot(Number(clr.dataset.slot)));
  }
}
createChaseUI();
function startRecorder(slot, btn){
  const frames = [];
  const fps = 20;
  const interval = 1000 / fps;
  let running = true;
  const t0 = performance.now();
  function sample(){
    if(!running) return;
    const t = Math.round(performance.now() - t0);
    const snap = state.heads.map(h=>({pan: h.pan, tilt: h.tilt}));
    frames.push({t, heads: snap});
    if(t >= 12000){ stop(); return; }
    setTimeout(sample, interval);
  }
  setTimeout(sample, 0);
  function stop(){
    running = false;
    btn.dataset.rec = '0';
    state.chases[slot] = { frames, fps, ts: Date.now() };
    const st = loadStorage(); st.chases = st.chases || {}; st.chases[slot] = state.chases[slot]; saveStorage(st);
    setStatus('Chase saved to slot '+(slot+1),1200);
  }
  return { stop };
}
function playChaseSlot(slot){
  const chase = state.chases[slot] || (loadStorage().chases && loadStorage().chases[slot]);
  if(!chase || !chase.frames || chase.frames.length===0){ setStatus('Chase empty',800); return; }
  setStatus('Playing chase '+(slot+1),900);
  const frames = chase.frames;
  const start = performance.now();
  function step(){
    const now = performance.now();
    const rel = now - start;
    let idx = 0;
    while(idx < frames.length - 1 && frames[idx+1].t <= rel) idx++;
    const f = frames[Math.min(idx, frames.length-1)];
    if(f){
      for(let i=0;i<state.heads.length;i++){
        const h = state.heads[i];
        const hf = f.heads[i] || f.heads[0] || {pan:h.pan, tilt:h.tilt};
        h.targetPan = hf.pan; h.targetTilt = hf.tilt;
      }
    }
    if(rel >= frames[frames.length-1].t + 40){ setStatus('Chase finished',900); return; }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}
function clearChaseSlot(slot){ state.chases[slot] = null; const st = loadStorage(); if(st.chases && st.chases[slot]){ delete st.chases[slot]; saveStorage(st); } setStatus('Chase '+(slot+1)+' cleared',900); }
(function loadChases(){ const st = loadStorage(); if(st.chases){ for(let i=0;i<5;i++) if(st.chases[i]) state.chases[i] = st.chases[i]; }})();
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000); last = now;
  if(state.power) state.time += dt;
  strobeAccum += dt;
  if(ui.dimmer) state.dimmer = Number(ui.dimmer.value)/100;
  if(ui.beamAngle) state.angle = Number(ui.beamAngle.value);
  if(ui.beamRange) state.range = Number(ui.beamRange.value);
  if(ui.globalColor) state.globalColor = ui.globalColor.value;
  if(ui.rainbowBtn) state.rainbow = ui.rainbowBtn.textContent.indexOf('ON') >= 0;
  if(ui.goboBtn) state.gobo = ui.goboBtn.textContent.indexOf('ON') >= 0;
  if(ui.strobeSpeed) state.strobeSpeed = Number(ui.strobeSpeed.value);
  if (ui.presetSpeed) state.presetSpeed = Number(ui.presetSpeed.value);
  for(let i=0;i<state.heads.length;i++){
    const h = state.heads[i];
    let sumPan=0, sumTilt=0, cnt=0;
    for(let p=0;p<state.presetActive.length;p++){
      if(state.presetActive[p]){ const off = presetOffset(p, state.time, i); sumPan += off.pan; sumTilt += off.tilt; cnt++; }
    }
    if(cnt>0){ h.targetPan = sumPan / cnt; h.targetTilt = sumTilt / cnt; }
    if(ui.modeSelect && ui.modeSelect.value === 'manual' && Number(ui.manualHeadSelect.value) === h.id){
      h.targetPan = Number(ui.manualPan.value);
      h.targetTilt = Number(ui.manualTilt.value);
    }
    h.pan = lerp(h.pan !== undefined ? h.pan : h.targetPan, h.targetPan, SMOOTH);
    h.tilt = lerp(h.tilt !== undefined ? h.tilt : h.targetTilt, h.targetTilt, SMOOTH);
    h.intensity = state.dimmer;
    if(state.prismaRotate){ h.prismRotation = (h.prismRotation || 0) + dt * 60; } else { h.prismRotation = 0; }
    h.angle = state.angle; h.range = state.range;
  }
  drawBackground();
  drawHeadMounts();
  drawWallwashers();
  drawParleds();
  drawMiniBrutes();
  drawMartins();
  for(const h of state.heads){
    if(strobeVisible(h.id)) drawBeam(h);
    updateCrossColor();
    // ‚ö†Ô∏è TIDAK ADA updateGoboColorShift() ‚Üí tidak ada animasi pergeseran warna
  }
  drawHeadMarkers();
  requestAnimationFrame(loop);
}
state.crossColor = false;
let lastCrossChange = performance.now();
let crossColorToggle = false;
if (ui.crossSpeed && ui.crossSpeedLabel) {
  ui.crossSpeed.addEventListener("input", (e) => {
    ui.crossSpeedLabel.textContent = Number(e.target.value).toFixed(1);
  });
}
if (ui.crossColorBtn) {
  ui.crossColorBtn.addEventListener("click", () => {
    state.crossColor = !state.crossColor;
    ui.crossColorBtn.textContent = state.crossColor ? "CROSS COLOR ON" : "CROSS COLOR OFF";
    if (state.crossColor) {
      setStatus("Cross Color aktif üé®", 700);
      lastCrossChange = performance.now();
    } else {
      setStatus("Cross Color dimatikan, reset ke putih ‚ö™", 700);
      for (const h of state.heads) {
        h.color = '#ffffff';
      }
    }
  });
}
function updateCrossColor() {
  if (!state.crossColor) return;
  const now = performance.now();
  const colorA = ui.colorA?.value || '#ffffff';
  const colorB = ui.colorB?.value || '#b300ff';
  const speedSec = parseFloat(ui.crossSpeed?.value || 1);
  const delay = speedSec * 1000;
  if (now - lastCrossChange >= delay) {
    lastCrossChange = now;
    crossColorToggle = !crossColorToggle;
    for (let i = 0; i < state.heads.length; i++) {
      const h = state.heads[i];
      const isEven = i % 2 === 0;
      h.color = crossColorToggle
        ? (isEven ? colorA : colorB)
        : (isEven ? colorB : colorA);
    }
  }
}
requestAnimationFrame(loop);
ui.beamCount && ui.beamCount.addEventListener('input', e=>{ initHeads(Number(e.target.value)); setStatus('Beams '+e.target.value,700); });
ui.dimmer && ui.dimmer.addEventListener('input', ()=> setStatus('Dimmer '+Math.round(Number(ui.dimmer.value))+'%',700));
ui.beamAngle && ui.beamAngle.addEventListener('input', ()=> setStatus('Angle '+ui.beamAngle.value+'¬∞',700));
ui.beamRange && ui.beamRange.addEventListener('input', ()=> setStatus('Range '+ui.beamRange.value+'px',700));
ui.rainbowBtn && ui.rainbowBtn.addEventListener('click', ()=>{
  const on = ui.rainbowBtn.textContent.indexOf('ON') >= 0;
  if(on){ ui.rainbowBtn.textContent = 'RAINBOW OFF'; setStatus('Rainbow OFF',700); } else { ui.rainbowBtn.textContent = 'RAINBOW ON'; setStatus('Rainbow ON',700); }
});
ui.goboBtn && ui.goboBtn.addEventListener('click', ()=>{ const on = ui.goboBtn.textContent.indexOf('ON') >= 0; if(on){ ui.goboBtn.textContent='AURORA OFF'; setStatus('Aurora OFF',700); } else { ui.goboBtn.textContent='AURORA ON'; setStatus('Aurora ON',700); } });
ui.powerBtn && ui.powerBtn.addEventListener('click', ()=>{ state.power = !state.power; ui.powerBtn.textContent = state.power ? 'POWER ON' : 'POWER OFF'; setStatus(state.power ? 'Power ON' : 'Power OFF',700); });
ui.modeSelect && ui.modeSelect.addEventListener('change', (e)=>{ ui.manualArea.style.display = e.target.value === 'manual' ? 'block' : 'none'; setStatus('Mode '+e.target.value,700); });
ui.manualHeadSelect && ui.manualHeadSelect.addEventListener('change', (e)=>{ state.manualSelected = Number(e.target.value); updateManualControls(state.manualSelected); });
ui.manualPan && ui.manualPan.addEventListener('input', (e)=>{ const id = Number(ui.manualHeadSelect.value); const h = state.heads.find(x=>x.id===id); if(h) h.targetPan = Number(e.target.value); });
ui.manualTilt && ui.manualTilt.addEventListener('input', (e)=>{ const id = Number(ui.manualHeadSelect.value); const h = state.heads.find(x=>x.id===id); if(h) h.targetTilt = Number(e.target.value); });
ui.manualColor && ui.manualColor.addEventListener('input', (e)=>{ const id = Number(ui.manualHeadSelect.value); const h = state.heads.find(x=>x.id===id); if(h){ h.color = e.target.value; setStatus('Color set',700); } });
document.addEventListener('DOMContentLoaded', () => {
  const strobeButtons = document.querySelectorAll('.strobe-btn');
  const prismaButtons = document.querySelectorAll('.prisma-btn');
  if (strobeButtons.length > 0) {
    strobeButtons.forEach(btn => {
      btn.addEventListener('click', e => {
        strobeButtons.forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        const mode = e.target.dataset.mode;
        state.strobeMode = mode;
        setStatus('Strobe mode: ' + mode, 700);
      });
    });
  }
  if (prismaButtons.length > 0) {
    prismaButtons.forEach(btn => {
      btn.addEventListener('click', e => {
        prismaButtons.forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        const mode = e.target.dataset.mode;
        state.prismaMode = mode;
        setStatus('Prisma mode: ' + mode, 700);
      });
    });
  }
  if (ui.strobeSpeed) {
    ui.strobeSpeed.addEventListener('input', e => {
      state.strobeSpeed = Number(e.target.value);
      setStatus('Strobe Speed: ' + e.target.value + ' Hz', 700);
    });
  }
});
document.getElementById('saveHeadA') && document.getElementById('saveHeadA').addEventListener('click', ()=> saveHeadSlot(state.manualSelected, 'A'));
document.getElementById('loadHeadA') && document.getElementById('loadHeadA').addEventListener('click', ()=> loadHeadSlot(state.manualSelected, 'A'));
document.getElementById('saveHeadB') && document.getElementById('saveHeadB').addEventListener('click', ()=> saveHeadSlot(state.manualSelected, 'B'));
document.getElementById('loadHeadB') && document.getElementById('loadHeadB').addEventListener('click', ()=> loadHeadSlot(state.manualSelected, 'B'));
document.getElementById('saveAll') && document.getElementById('saveAll').addEventListener('click', ()=> saveAllSlot('ALL'));
document.getElementById('loadAll') && document.getElementById('loadAll').addEventListener('click', ()=> loadAllSlot('ALL'));
document.getElementById('clearSlots') && document.getElementById('clearSlots').addEventListener('click', ()=> { localStorage.removeItem(STORAGE_KEY); setStatus('Slots cleared',700); });
document.getElementById("miniBruteToggle").addEventListener("click", () => {
  state.miniBruteOn = !state.miniBruteOn;
  setStatus("MiniBrute " + (state.miniBruteOn ? "ON" : "OFF"), 1000);
});
function saveHeadSlot(hid, slot){ const st = loadStorage(); st.heads = st.heads || {}; st.heads[slot] = st.heads[slot] || {}; const h = state.heads.find(x=>x.id===hid); if(h) st.heads[slot][hid] = { pan: h.pan, tilt: h.tilt, color: h.color, ts:Date.now() }; saveStorage(st); }
function loadHeadSlot(hid, slot){ const st = loadStorage(); if(!st.heads || !st.heads[slot] || !st.heads[slot][hid]){ setStatus('Slot empty',800); return; } const s = st.heads[slot][hid]; const h = state.heads.find(x=>x.id===hid); if(h){ h.targetPan = s.pan; h.targetTilt = s.tilt; h.color = s.color || h.color; setStatus('Head loaded',800); } }
function saveAllSlot(slot){ const data = state.heads.map(h=>({id:h.id, pan:h.pan, tilt:h.tilt, color:h.color})); const st = loadStorage(); st.all = st.all || {}; st.all[slot] = {time:Date.now(), heads:data}; saveStorage(st); }
function loadAllSlot(slot){ const st = loadStorage(); if(!st.all || !st.all[slot]){ setStatus('Slot empty',800); return; } const data = st.all[slot].heads; for(const d of data){ const h = state.heads.find(x=>x.id===d.id); if(h){ h.targetPan = d.pan; h.targetTilt = d.tilt; h.color = d.color || h.color; } } setStatus('All loaded',800); }
function setStatus(text, ttl=900){ ui.powerBtn.textContent = text; clearTimeout(ui._t); ui._t = setTimeout(()=> ui.powerBtn.textContent = state.power ? 'POWER ON' : 'POWER OFF', ttl); }
ui.tronVideoFile.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    createTronMediaElement(ev.target.result, file.type);
    saveTronState(ev.target.result, file.type);
  };
  reader.readAsDataURL(file);
});
function createTronMediaElement(src, type) {
  if (tronMedia) tronMedia.remove();
  if (type.startsWith("video/")) {
    tronMedia = document.createElement("video");
    tronMedia.src = src;
    tronMedia.loop = true;
    tronMedia.muted = true;
    tronMedia.autoplay = true;
    tronMedia.playsInline = true;
    tronMedia.style.display = "none";
    document.body.appendChild(tronMedia);
    tronMedia.addEventListener("loadeddata", () => {
      tronMediaReady = true;
      setStatus("Video Loaded", 1000);
    });
  } else if (type.startsWith("image/")) {
    tronMedia = document.createElement("img");
    tronMedia.src = src;
    tronMedia.style.display = "none";
    document.body.appendChild(tronMedia);
    tronMedia.onload = () => {
      tronMediaReady = true;
      setStatus("Image Loaded", 1000);
    };
  }
}
let tronMedia = null;
let tronMediaReady = false;
function saveTronState(dataURL, type) {
  const st = loadStorage();
  st.tronMedia = { dataURL, type };
  saveStorage(st);
}
function restoreTronState() {
  const st = loadStorage();
  if (st.tronMedia) {
    createTronMediaElement(st.tronMedia.dataURL, st.tronMedia.type);
  }
}
restoreTronState();
if (ui.playTron) ui.playTron.addEventListener("click", () => {
  if (tronMedia && tronMedia.tagName === "VIDEO") tronMedia.play();
});
if (ui.pauseTron) ui.pauseTron.addEventListener("click", () => {
  if (tronMedia && tronMedia.tagName === "VIDEO") tronMedia.pause();
});
if (ui.clearTron) ui.clearTron.addEventListener("click", () => {
  tronMediaReady = false;
  if (tronMedia) {
    if (tronMedia.tagName === "VIDEO") tronMedia.pause();
    tronMedia.remove();
    tronMedia = null;
  }
  const st = loadStorage();
  delete st.tronMedia;
  saveStorage(st);
  setStatus("Cleared", 700);
});
const originalDrawBackground = drawBackground;
drawBackground = function() {
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (tronMediaReady && tronMedia) {
    let w = canvas.width, h = canvas.height;
    let x = 0, y = 0;
    if (tronMedia.videoWidth || tronMedia.naturalWidth) {
      const mediaW = tronMedia.videoWidth || tronMedia.naturalWidth;
      const mediaH = tronMedia.videoHeight || tronMedia.naturalHeight;
      const aspect = mediaW / mediaH;
      const canvasAspect = canvas.width / canvas.height;
      if (aspect > canvasAspect) {
        h = canvas.height;
        w = h * aspect;
      } else {
        w = canvas.width;
        h = w / aspect;
      }
      x = (canvas.width - w) / 2;
      y = (canvas.height - h) / 2;
    }
    ctx.drawImage(tronMedia, x, y, w, h);
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
};
// === GOBO COLOR FX ===
state.goboColorFx = false;
state.goboColors = ['#ff00ff', '#ffffff', '#ff66ff'];
ui.goboColorBtn = document.getElementById('goboColorBtn');
ui.goboColor1 = document.getElementById('goboColor1');
ui.goboColor2 = document.getElementById('goboColor2');
ui.goboColor3 = document.getElementById('goboColor3');
ui.goboColorBtn.addEventListener('click', () => {
  state.goboColorFx = !state.goboColorFx;
  ui.goboColorBtn.textContent = state.goboColorFx ? 'GOBO COLOR ON' : 'GOBO COLOR OFF';
  setStatus(state.goboColorFx ? 'Efek Gobo Warna Aktif üé®' : 'Efek Gobo Warna Dimatikan ‚ö™', 700);
});
function updateGoboColors() {
  state.goboColors = [ui.goboColor1.value, ui.goboColor2.value, ui.goboColor3.value];
}
ui.goboColor1.addEventListener('input', updateGoboColors);
ui.goboColor2.addEventListener('input', updateGoboColors);
ui.goboColor3.addEventListener('input', updateGoboColors);
// ‚ö†Ô∏è TIDAK ADA FUNGSI updateGoboColorShift()
ui.wallCount && ui.wallCount.addEventListener('input', (e)=>{ ui.wallCountLabel.textContent = e.target.value; });
ui.spawnWall && ui.spawnWall.addEventListener('click', ()=>{ const v = Number(ui.wallCount.value); spawnWallwashers(v); setStatus('Wallwashers spawned: '+v,800); });
ui.clearWall && ui.clearWall.addEventListener('click', ()=>{ state.wallwashers = []; saveStateUI(); setStatus('Wallwashers cleared',700); });
ui.martinColor.addEventListener("input", (e) => {
  if (!state.martins) return;
  const id = state.selectedMartin ?? 0;
  if (state.martins[id]) state.martins[id].color = e.target.value;
  saveStateUI();
});
ui.martinCount = document.getElementById("martinCount");
ui.martinCountLabel = document.getElementById("martinCountLabel");
ui.spawnMartin = document.getElementById("spawnMartin");
ui.clearMartin = document.getElementById("clearMartin");
ui.martinCount.addEventListener("input", (e) => {
  ui.martinCountLabel.textContent = e.target.value;
});
ui.spawnMartin.addEventListener("click", () => {
  spawnMartins(parseInt(ui.martinCount.value));
});
ui.clearMartin.addEventListener("click", () => {
  state.martins = [];
  saveStateUI();
});
ui.martinScale.addEventListener('input', (e) => {
  if (!state.martins) return;
  const id = state.selectedMartin ?? 0;
  const m = state.martins[id];
  if (m) {
    m.scale = parseFloat(e.target.value);
    saveStateUI();
  }
});
ui.martinRotate.addEventListener('input', (e) => {
  if (!state.martins) return;
  const id = state.selectedMartin ?? 0;
  const m = state.martins[id];
  if (m) {
    m.rotation = parseFloat(e.target.value);
    saveStateUI();
  }
});
ui.martinColorMode.addEventListener("change", (e) => {
  state.martinColorMode = e.target.value;
  saveStateUI();
});
ui.parCount && ui.parCount.addEventListener('input', (e)=>{ ui.parCountLabel.textContent = e.target.value; });
ui.spawnPar && ui.spawnPar.addEventListener('click', ()=>{ const v = Number(ui.parCount.value); spawnParleds(v); setStatus('Parleds spawned: '+v,800); });
ui.clearPar && ui.clearPar.addEventListener('click', ()=>{ state.parleds = []; saveStateUI(); setStatus('Parleds cleared',700); });
if(state.wallwashers.length === 0 && Number(ui.wallCount ? ui.wallCount.value : 0) > 0) spawnWallwashers(Number(ui.wallCount ? ui.wallCount.value : 0));
if(state.parleds.length === 0 && Number(ui.parCount ? ui.parCount.value : 0) > 0) spawnParleds(Number(ui.parCount ? ui.parCount.value : 0));
(function restoreAll(){
  const st = loadStorage();
  if(st.bgImage){}
  if(st.wallwashers) state.wallwashers = st.wallwashers;
  if(st.parleds) state.parleds = st.parleds;
  if(st.miniBrutePos) state.miniBrutePos = st.miniBrutePos;
})();
window.GEBER = { state, initHeads, playChaseSlot, clearChaseSlot };
if(ui.wallScale){
  ui.wallScale.addEventListener('input', ()=>{
    if(state.selectedWall !== null && state.wallwashers){
      const w = state.wallwashers.find(x => x.id === state.selectedWall);
      if(w){ w.scale = Number(ui.wallScale.value); saveStateUI(); setStatus('Wall scale '+ui.wallScale.value,700); }
    }
  });
}
if(ui.wallRotate){
  ui.wallRotate.addEventListener('input', ()=>{
    if(state.selectedWall !== null && state.wallwashers){
      const w = state.wallwashers.find(x => x.id === state.selectedWall);
      if(w){ w.rotation = Number(ui.wallRotate.value); saveStateUI(); setStatus('Wall rotate '+ui.wallRotate.value+'¬∞',700); }
    }
  });
}
canvas.addEventListener('click', (e)=>{
  if(state.dragging) return;
  const r = canvas.getBoundingClientRect(); const px = e.clientX - r.left, py = e.clientY - r.top;
  state.selectedWall = null;
  for(const w of state.wallwashers){
    const barH = Math.round(canvas.height * 0.36) * (w.scale || 1);
    const barW = Math.max(18, Math.round(canvas.width * 0.02)) * (w.scale || 1);
    const dx = px - w.x;
    const dy = py - (w.y - Math.round(canvas.height * 0.36)/2 + (barH/2));
    const rot = (w.rotation || 0) * Math.PI/180;
    const localX = dx * Math.cos(-rot) - dy * Math.sin(-rot);
    const localY = dx * Math.sin(-rot) + dy * Math.cos(-rot);
    if(localX >= -barW/2 - 8 && localX <= barW/2 + 8 && localY >= -barH/2 - 8 && localY <= barH/2 + 8){
      state.selectedWall = w.id;
      ui.wallScale.value = w.scale || 1;
      ui.wallRotate.value = w.rotation || 0;
      setStatus('Selected Wallwasher '+(w.id+1),700);
      break;
    }
  }
});
// =============== SAVE / LOAD PROJECT ===============
function saveProjectToFile() {
  try {
    const projectData = {
      version: "geber-lighting-v1",
      timestamp: Date.now(),
      state: {
        power: state.power,
        presetSpeed: state.presetSpeed,
        dimmer: state.dimmer,
        angle: state.angle,
        range: state.range,
        globalColor: state.globalColor,
        rainbow: state.rainbow,
        gobo: state.gobo,
        strobeMode: state.strobeMode,
        strobeSpeed: state.strobeSpeed,
        prismaMode: state.prismaMode,
        prismaRotate: state.prismaRotate,
        heads: state.heads.map(h => ({ ...h })),
        wallwashers: state.wallwashers.map(w => ({ ...w })),
        parleds: state.parleds.map(p => ({ ...p })),
        martins: state.martins ? state.martins.map(m => ({ ...m })) : [],
        miniBrutes: state.miniBrutes ? state.miniBrutes.map(mb => ({ ...mb })) : [],
        miniBruteOn: state.miniBruteOn,
        crossColor: state.crossColor,
        goboColorFx: state.goboColorFx,
        goboColors: [...state.goboColors],
        martinColorMode: state.martinColorMode,
        beamCount: Number(ui.beamCount.value || 8),
        wallCount: Number(ui.wallCount.value || 0),
        parCount: Number(ui.parCount.value || 0),
        martinCount: Number(ui.martinCount.value || 0),
        colorA: ui.colorA.value,
        colorB: ui.colorB.value,
        crossSpeed: ui.crossSpeed.value,
        goboColor1: ui.goboColor1.value,
        goboColor2: ui.goboColor2.value,
        goboColor3: ui.goboColor3.value,
      }
    };
    const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `geber_project_${new Date().toISOString().slice(0,16).replace(/:/g,'-')}.geber`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
    setStatus('Project saved!', 1200);
  } catch (e) {
    console.error("Save failed:", e);
    setStatus('Save failed!', 1200);
  }
}
function loadProjectFromFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.version || !data.state) throw new Error("Invalid project file");
      const s = data.state;
      state.power = s.power ?? true;
      state.presetSpeed = s.presetSpeed ?? 1.0;
      state.dimmer = s.dimmer ?? 0.95;
      state.angle = s.angle ?? 12;
      state.range = s.range ?? 900;
      state.globalColor = s.globalColor ?? '#ffffff';
      state.rainbow = s.rainbow ?? false;
      state.gobo = s.gobo ?? false;
      state.strobeMode = s.strobeMode ?? 'off';
      state.strobeSpeed = s.strobeSpeed ?? 14;
      state.prismaMode = s.prismaMode ?? 'none';
      state.prismaRotate = s.prismaRotate ?? false;
      state.crossColor = s.crossColor ?? false;
      state.goboColorFx = s.goboColorFx ?? false;
      state.goboColors = s.goboColors ? [...s.goboColors] : ['#ff00ff', '#ffffff', '#ff66ff'];
      state.martinColorMode = s.martinColorMode ?? 'global';
      state.miniBruteOn = s.miniBruteOn ?? false;
      state.heads = s.heads ? s.heads.map(h => ({ ...h })) : [];
      state.wallwashers = s.wallwashers ? s.wallwashers.map(w => ({ ...w })) : [];
      state.parleds = s.parleds ? s.parleds.map(p => ({ ...p })) : [];
      state.martins = s.martins ? s.martins.map(m => ({ ...m })) : [];
      state.miniBrutes = s.miniBrutes ? s.miniBrutes.map(mb => ({ ...mb })) : [];
      ui.beamCount.value = s.beamCount ?? state.heads.length;
      ui.wallCount.value = s.wallCount ?? state.wallwashers.length;
      ui.parCount.value = s.parCount ?? state.parleds.length;
      ui.martinCount.value = s.martinCount ?? (state.martins?.length || 0);
      ui.beamCountLabel.textContent = s.beamCount ?? state.heads.length;
      ui.wallCountLabel.textContent = s.wallCount ?? state.wallwashers.length;
      ui.parCountLabel.textContent = s.parCount ?? state.parleds.length;
      ui.martinCountLabel.textContent = s.martinCount ?? (state.martins?.length || 0);
      ui.powerBtn.textContent = state.power ? 'POWER ON' : 'POWER OFF';
      ui.rainbowBtn.textContent = state.rainbow ? 'RAINBOW ON' : 'RAINBOW OFF';
      ui.goboBtn.textContent = state.gobo ? 'AURORA ON' : 'AURORA OFF';
      ui.crossColorBtn.textContent = state.crossColor ? 'CROSS COLOR ON' : 'CROSS COLOR OFF';
      ui.goboColorBtn.textContent = state.goboColorFx ? 'GOBO COLOR ON' : 'GOBO COLOR OFF';
      ui.miniBruteToggle.textContent = state.miniBruteOn ? 'BRUTE ON' : 'BRUTE OFF';
      document.querySelectorAll('.prisma-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === state.prismaMode);
      });
      document.querySelectorAll('.strobe-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === state.strobeMode);
      });
      if (s.colorA) ui.colorA.value = s.colorA;
      if (s.colorB) ui.colorB.value = s.colorB;
      if (s.crossSpeed) {
        ui.crossSpeed.value = s.crossSpeed;
        ui.crossSpeedLabel.textContent = Number(s.crossSpeed).toFixed(1);
      }
      if (s.goboColor1) ui.goboColor1.value = s.goboColor1;
      if (s.goboColor2) ui.goboColor2.value = s.goboColor2;
      if (s.goboColor3) ui.goboColor3.value = s.goboColor3;
      buildManualSelect();
      buildPresetsUI();
      const faders = document.querySelectorAll('.presetFader');
      state.presetActive.forEach((active, i) => {
        if (faders[i]) faders[i].value = active ? 100 : 0;
      });
      setStatus('Project loaded!', 1500);
    } catch (err) {
      console.error("Load failed:", err);
      setStatus('Invalid project file!', 1500);
    }
  };
  reader.readAsText(file);
}
document.getElementById('saveProjectBtn').addEventListener('click', saveProjectToFile);
document.getElementById('loadProjectBtn').addEventListener('click', () => {
  document.getElementById('loadProjectInput').click();
});
document.getElementById('loadProjectInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (file) {
    loadProjectFromFile(file);
    e.target.value = '';
  }
});
const strobeSpeedInput = document.getElementById("strobeSpeed");
const saveSpeedBtn = document.getElementById("saveStrobeSpeedBtn");

// ambil / buat penyimpanan lokal
let savedStrobeSpeeds = JSON.parse(localStorage.getItem("savedStrobeSpeeds") || "{}");

// fungsi untuk update state saat user ubah speed
strobeSpeedInput.addEventListener("input", () => {
  state.strobeSpeed = Number(strobeSpeedInput.value);
});

// fungsi simpan speed ke mode aktif
saveSpeedBtn.addEventListener("click", () => {
  const mode = state.strobeMode || "off";
  const val = Number(strobeSpeedInput.value);
  savedStrobeSpeeds[mode] = val;
  localStorage.setItem("savedStrobeSpeeds", JSON.stringify(savedStrobeSpeeds));
  setStatus(`Saved speed ${val}Hz for mode ${mode}`, 1000);
});

// setiap kali ganti mode strobo ‚Üí load speed yg tersimpan
document.querySelectorAll(".strobe-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const mode = btn.dataset.mode;
    state.strobeMode = mode;

    // ambil speed sesuai mode
    const saved = savedStrobeSpeeds[mode];
    if (saved) {
      strobeSpeedInput.value = saved;
      state.strobeSpeed = saved;
      setStatus(`Loaded saved speed ${saved}Hz`, 1000);
    } else {
      state.strobeSpeed = Number(strobeSpeedInput.value);
    }

    // update tampilan tombol aktif
    document.querySelectorAll(".strobe-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  });
});
// =================================================================================
// LOGIKA KONTROL KEYBOARD TERBARU
// =================================================================================

// Helper function untuk mendapatkan nama preset (Jika tersedia)
function presetName(index) {
    if (index === 0) return 'Manual';
    if (index >= 1 && index <= 12) return `P${index}`;
    return `Preset ${index + 1}`;
}

// ---------------------------------------------------------------------------------
// A. KONTROL PRESET (P1 - P13)
// F1-F12 untuk P1-P12, Tombol 1 untuk P13
// ---------------------------------------------------------------------------------

function handlePresetKey(key, presetIndex) {
    // Tombol 1 di keyboard, Preset ke-13 (index 12)
    if (key === '1') {
        presetIndex = 12; // P13
    }
    // Tombol F1 sampai F12, Preset P1 sampai P12 (index 0 sampai 11)
    else if (key.startsWith('F') && key.length > 1) {
        const fKey = parseInt(key.substring(1)); // Ambil angka setelah 'F'
        if (fKey >= 1 && fKey <= 12) {
            presetIndex = fKey - 1; // F1 -> index 0 (P1), F12 -> index 11 (P12)
        } else {
            return; // Bukan tombol F yang valid
        }
    } else {
        return; // Bukan tombol Preset yang diminta
    }

    const allFaders = document.querySelectorAll('.presetFader');
    const allBoxes = document.querySelectorAll('.presetBox');
    const totalPresets = state.presetActive.length;

    // Pastikan indeks preset yang ditekan valid
    if (presetIndex >= 0 && presetIndex < totalPresets) {
        
        // 1. Matikan semua Preset (All OFF)
        for (let i = 0; i < totalPresets; i++) {
            // Update State ke OFF
            state.presetActive[i] = false;
            // Update UI Fader Value ke 0
            if (allFaders[i]) allFaders[i].value = 0;
            // Reset warna Box ke default
            if (allBoxes[i]) allBoxes[i].style.backgroundColor = '#092023'; // Asumsi warna default dari CSS
        }

        // 2. Aktifkan Preset yang dipilih (Selected ON)
        
        // Update State ke ON
        state.presetActive[presetIndex] = true;
        
        // Update UI Fader Value ke 100 (Aktif)
        if (allFaders[presetIndex]) allFaders[presetIndex].value = 100;
        
        // Beri warna Box untuk Preset yang aktif
        if (allBoxes[presetIndex]) allBoxes[presetIndex].style.backgroundColor = 'var(--accent)'; 
        
        // Beri feedback status
        if (typeof setStatus === 'function') {
            setStatus(`${presetName(presetIndex + 1)} ON (${key})`);
        }
        
        // Memastikan fader UI ter-update (jika ada fungsi render UI)
        if (typeof renderUI === 'function') {
            renderUI();
        }
        
        // Pastikan gerakan dikirim ke DMX (jika ada fungsi sendData)
        if (typeof sendData === 'function') {
            sendData();
        }
    }
}

// =================================================================================
// LOGIKA KONTROL KEYBOARD LENGKAP (FINAL)
// Ditempatkan di dalam tag <script> di bagian akhir file HTML
// =================================================================================

// Daftar mode yang sesuai dengan urutan tombol di HTML
const STROBE_MODES = ['off', 'blink', 'flow', 'random', 'alternate', 'chase', 'converge', 'split']; // 8 mode
const PRISMA_MODES = ['none', 'split3', 'split5', 'split7', 'linear', 'combo']; // 6 mode
const COLOR_MODES = ['rainbow', 'crossColor', 'goboColor']; // Mode Warna yang dikontrol

// Helper function untuk mendapatkan nama preset (sesuaikan jika perlu)
function presetName(i){ 
    // Ini hanyalah contoh nama untuk feedback status
    return ['Atas bawah','Pargoy2','Fan','Circle','SlowTilt','Circle2','Spiral','Pargoy terbaru','GTW','ZigZag','ZigZag2','Zigzag3','Circle3'][i] || `P${i+1}`; 
}


// ---------------------------------------------------------------------------------
// A. FUNGSI HANDLE PRESET KEY (DENGAN TOGGLE)
// F1-F12, Tombol 1
// ---------------------------------------------------------------------------------
function handlePresetKey(key, event) {
    let presetIndex;
    // Tombol 1 -> P13 (index 12)
    if (key === '1') {
        presetIndex = 12;
    } 
    // Tombol F1-F12 -> P1-P12 (index 0-11)
    else if (key.startsWith('F') && key.length > 1) {
        const fKey = parseInt(key.substring(1));
        if (fKey >= 1 && fKey <= 12) {
            presetIndex = fKey - 1; 
        } else {
            return;
        }
    } else {
        return;
    }
    
    // Mencegah tindakan default browser jika ada
    if(event) event.preventDefault();

    const allFaders = document.querySelectorAll('.presetFader');
    const allBoxes = document.querySelectorAll('.presetBox');
    const totalPresets = state.presetActive.length;

    if (presetIndex >= 0 && presetIndex < totalPresets) {
        
        // Cek status saat ini untuk fitur Toggle
        const isCurrentlyActive = state.presetActive[presetIndex];

        // 1. Matikan semua Preset (All OFF)
        for (let i = 0; i < totalPresets; i++) {
            state.presetActive[i] = false;
            if (allFaders[i]) allFaders[i].value = 0;
            if (allBoxes[i]) allBoxes[i].style.backgroundColor = '#092023'; 
        }

        if (!isCurrentlyActive) {
            // Jika sebelumnya TIDAK aktif, maka AKTIFKAN preset ini (Toggle ON)
            state.presetActive[presetIndex] = true;
            
            if (allFaders[presetIndex]) allFaders[presetIndex].value = 100;
            if (allBoxes[presetIndex]) allBoxes[presetIndex].style.backgroundColor = 'var(--accent)'; 
            
            // Matikan mode warna saat preset aktif
            state.rainbow = false;
            state.crossColor = false;
            state.goboColorFx = false;
            
            if (typeof setStatus === 'function') {
                setStatus(`${presetName(presetIndex)} ON (${key})`);
            }
        } else {
            // Jika sebelumnya SUDAH aktif, maka biarkan semua tetap mati (Toggle OFF)
            if (typeof setStatus === 'function') {
                setStatus(`Semua Gerakan OFF (${key})`);
            }
        }
        
        // Kirim data DMX
        if (typeof sendData === 'function') {
            sendData();
        }
    }
}

// ---------------------------------------------------------------------------------
// B. KONTROL MODE WARNA EKSKLUSIF (A, S, D)
// ---------------------------------------------------------------------------------
function handleColorKey(key) {
    const keyLower = key.toLowerCase();
    let selectedMode = '';
    
    // Tentukan mode yang dipilih
    if (keyLower === 'a') selectedMode = 'rainbow';
    else if (keyLower === 's') selectedMode = 'crossColor';
    else if (keyLower === 'd') selectedMode = 'goboColor';
    else return;
    
    // Cek apakah mode yang dipilih sudah aktif
    const isAlreadyActive = (
        (selectedMode === 'rainbow' && state.rainbow) ||
        (selectedMode === 'crossColor' && state.crossColor) ||
        (selectedMode === 'goboColor' && state.goboColorFx) 
    );
    
    // 1. Matikan semua mode warna terlebih dahulu
    state.rainbow = false;
    state.crossColor = false;
    state.goboColorFx = false;

    if (!isAlreadyActive) {
        // Jika belum aktif, aktifkan mode yang dipilih
        if (selectedMode === 'rainbow') state.rainbow = true;
        else if (selectedMode === 'crossColor') state.crossColor = true;
        else if (selectedMode === 'goboColor') state.goboColorFx = true;

        if (typeof setStatus === 'function') {
            setStatus(`${selectedMode.toUpperCase()} ON (${key.toUpperCase()})`);
        }
    } else {
        // Jika sudah aktif, biarkan semua mati (toggle off)
        if (typeof setStatus === 'function') {
            setStatus(`Color Modes OFF (${key.toUpperCase()})`);
        }
    }
    
    // Kirim data DMX
    if (typeof sendData === 'function') {
        sendData();
    }
}


// ---------------------------------------------------------------------------------
// C. EVENT LISTENER KEYDOWN (Tombol Ditekan)
// ---------------------------------------------------------------------------------

document.addEventListener('keydown', (e) => {
    // Mencegah tindakan default browser
    const key = e.key;
    const keyLower = key.toLowerCase();
    
    // Daftar semua tombol yang kita gunakan untuk mencegah default action browser (seperti F1, F5)
    if (key.startsWith('F') || ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'q', 'w', 'e', 'r', 't', 'y', 'a', 's', 'd', 'm'].includes(keyLower)) {
        e.preventDefault(); 
    }
    
    // Pastikan fokus tidak di kolom input/teks
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    let modeValue; 

    // === 1. KONTROL PRESET (P1-P13) ===
    if (key === '1' || key.startsWith('F')) {
        handlePresetKey(key, e); 
        return; 
    }

    // === 2. KONTROL MODE WARNA (A, S, D) ===
    if (['a', 's', 'd'].includes(keyLower)) {
        handleColorKey(key);
        return;
    }
    
// === 3. KONTROL STROBE MODE (2=off, 3=Mode 1, ..., 9=Mode 7) ===
const strobeKeys = ['2', '3', '4', '5', '6', '7', '8', '9'];
if (strobeKeys.includes(key)) {
    const modeIndex = parseInt(key) - 2;

    if (modeIndex >= 0 && modeIndex < STROBE_MODES.length) {
        const modeValue = STROBE_MODES[modeIndex];
        state.strobeMode = modeValue;

        // üî• Tambahan penting biar load speed yang disimpan
        const saved = savedStrobeSpeeds[modeValue];
        if (saved) {
            strobeSpeedInput.value = saved;
            state.strobeSpeed = saved;
            if (typeof setStatus === "function") setStatus(`Loaded saved speed ${saved}Hz`);
        }

        // Update UI tombol aktif
        document.querySelectorAll('#strobeButtons .strobe-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === modeValue);
        });

        if (typeof setStatus === 'function') {
            const statusText = (modeValue === 'off')
                ? `Strobe OFF (${key})`
                : `Strobe Mode ${modeIndex} (${key})`;
            setStatus(statusText);
        }

        // Kirim data ke lampu
        if (typeof sendData === 'function') sendData();
    }
}


    // === 4. KONTROL PRISMA MODE (Q=off, W=Mode 1, ..., Y=Mode 5) ===
    const prismaKeyboardKeys = ['q', 'w', 'e', 'r', 't', 'y']; 
    const keyIndex = prismaKeyboardKeys.indexOf(keyLower);
    
    if (keyIndex !== -1) {
        if (keyIndex >= 0 && keyIndex < PRISMA_MODES.length) {
            modeValue = PRISMA_MODES[keyIndex];
            
            state.prismaMode = modeValue; 
            
            // Update UI dan Status
            document.querySelectorAll('#prismaButtons .prisma-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === modeValue);
            });
            
            if (typeof setStatus === 'function') {
                const statusText = (modeValue === 'none') ? `Prisma OFF (${key.toUpperCase()})` : `Prisma Mode ${keyIndex} ON (${key.toUpperCase()})`;
                setStatus(statusText);
            }
            if (typeof sendData === 'function') {
                sendData();
            }
        }
    }
    
    // === 5. KONTROL MINI BRUTE ON (Momentary M) ===
    // Menggunakan state._miniBruteActive untuk mencegah pengiriman berulang saat ditahan
    if (keyLower === 'm' && !state._miniBruteActive) {
        state._miniBruteActive = true; 
        
        if (state.miniBruteOn !== undefined) {
            state.miniBruteOn = true; 
            if (typeof setStatus === 'function') {
                setStatus(`Mini Brute ON`);
            }
            if (typeof sendData === 'function') {
                sendData();
            }
        }
    }

});

// ---------------------------------------------------------------------------------
// D. EVENT LISTENER KEYUP (Tombol Dilepas)
// Untuk Mini Brute OFF
// ---------------------------------------------------------------------------------

document.addEventListener('keyup', (e) => {
    // Pastikan fokus tidak di kolom input/teks
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }

    // === KONTROL MINI BRUTE OFF (Momentary M) ===
    if (e.key.toLowerCase() === 'm') {
        state._miniBruteActive = false; 
        
        if (state.miniBruteOn !== undefined) {
            state.miniBruteOn = false; 
            if (typeof setStatus === 'function') {
                setStatus(`Mini Brute OFF`);
            }
            if (typeof sendData === 'function') {
                sendData();
            }
        }
    }
});
// === KEYBOARD CONTROL UNTUK CHASE RECORDER (Z‚ÄìB) ===
document.addEventListener("keydown", (e) => {
  if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;

  const key = e.key.toLowerCase();
  const chaseMap = { z: 0, x: 1, c: 2, v: 3, b: 4 };
  if (!(key in chaseMap)) return;

  const slot = chaseMap[key];
  const buttons = ui.chaseControls.querySelectorAll("button");
  const recBtn = [...buttons].find(b => b.textContent === "REC" && b.dataset.slot == slot);
  const playBtn = [...buttons].find(b => b.textContent === "PLAY" && b.dataset.slot == slot);
  const clrBtn = [...buttons].find(b => b.textContent === "CLEAR" && b.dataset.slot == slot);

  // SHIFT = record, ALT = clear, normal = play
  if (e.shiftKey && recBtn) {
    recBtn.click();
    setStatus(`Record Chase ${slot + 1}`, 700);
  } else if (e.altKey && clrBtn) {
    clrBtn.click();
    setStatus(`Clear Chase ${slot + 1}`, 700);
  } else if (playBtn) {
    playBtn.click();
    setStatus(`Play Chase ${slot + 1}`, 700);
  }
});
// =================================================================================
// ===============================
// STROBE SPEED SAVE + TOGGLE PANEL (AMAN UNTUK DITARUH DI BAWAH)
// ===============================

// Tambahkan elemen baru ke objek ui yang sudah ada
ui.saveStrobeSpeedBtn = document.getElementById('saveStrobeSpeedBtn');
ui.toggleSpeedPanel = document.getElementById('toggleSpeedPanel');
ui.strobeSpeedPanel = document.getElementById('strobeSpeedPanel');

// Inisialisasi data kecepatan per-mode bila belum ada
if (!state.strobeSpeeds) {
  state.strobeSpeeds = {
    off: 14,
    blink: 14,
    flow: 14,
    random: 14,
    alternate: 14,
    chase: 14,
    converge: 14,
    split: 14
  };
}

// --- FUNGSI SIMPAN & LOAD ---
function loadStrobeSpeeds() {
  try {
    return JSON.parse(localStorage.getItem('strobeSpeeds') || '{}');
  } catch (e) {
    return {};
  }
}

function saveStrobeSpeeds(data) {
  localStorage.setItem('strobeSpeeds', JSON.stringify(data));
}

// --- LOAD SPEED YANG PERNAH DISIMPAN ---
const savedSpeeds = loadStrobeSpeeds();
if (Object.keys(savedSpeeds).length) {
  state.strobeSpeeds = savedSpeeds;
}

// --- SAAT TOMBOL MODE STROBO DIKLIK ---
document.querySelectorAll('#strobeButtons .strobe-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#strobeButtons .strobe-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.strobeMode = btn.dataset.mode;
    ui.strobeSpeed.value = state.strobeSpeeds[state.strobeMode] || 14;
  });
});

// --- TOMBOL SAVE SPEED ---
ui.saveStrobeSpeedBtn.addEventListener('click', () => {
  const val = Number(ui.strobeSpeed.value);
  state.strobeSpeeds[state.strobeMode] = val;
  saveStrobeSpeeds(state.strobeSpeeds);
  if (typeof setStatus === 'function') {
    setStatus(`Saved ${state.strobeMode.toUpperCase()} Speed: ${val} Hz`, 1000);
  } else {
    alert(`‚úÖ Speed mode ${state.strobeMode.toUpperCase()} disimpan (${val} Hz)!`);
  }
});

/* Auto save setiap perubahan posisi / spawn */
setInterval(() => {
  try {
    const data = {
      heads: state.heads,
      wallwashers: state.wallwashers,
      parleds: state.parleds,
      miniBrutes: state.miniBrutes,
      martins: state.martins
    };
    localStorage.setItem("geber_project", JSON.stringify(data));
  } catch(e) {}
}, 3000);

/* Saat aplikasi dibuka, otomatis restore data terakhir */
window.addEventListener("load", () => {
  try {
    const saved = JSON.parse(localStorage.getItem("geber_project"));
    if (saved) {
      if (saved.heads) state.heads = saved.heads;
      if (saved.wallwashers) state.wallwashers = saved.wallwashers;
      if (saved.parleds) state.parleds = saved.parleds;
      if (saved.miniBrutes) state.miniBrutes = saved.miniBrutes;
      if (saved.martins) state.martins = saved.martins;
      alert("‚úÖ Project otomatis dimuat dari penyimpanan lokal");
    }
  } catch(e) {}
});
// --- SLIDER UPDATE LANGSUNG (AUTO SAVE OPSIONAL) ---
ui.strobeSpeed.addEventListener('input', () => {
  const val = Number(ui.strobeSpeed.value);
  state.strobeSpeeds[state.strobeMode] = val;
  saveStrobeSpeeds(state.strobeSpeeds);
});

// --- TOMBOL TOGGLE PANEL (HIDE / SHOW) ---
ui.toggleSpeedPanel.addEventListener('click', () => {
  const p = ui.strobeSpeedPanel;
  if (p.style.display === 'none') {
    p.style.display = '';
    ui.toggleSpeedPanel.textContent = 'Hide';
  } else {
    p.style.display = 'none';
    ui.toggleSpeedPanel.textContent = 'Show';
  }
});
// === KONTROL PRESET SPEED DENGAN KEYOARD (K = pelan, L = cepat) ===
document.addEventListener("keydown", (e) => {
  if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;

  const key = e.key.toLowerCase();
  const presetSpeed = document.getElementById("presetSpeed");
  if (!presetSpeed) return; // kalau elemen belum ketemu

  let current = Number(presetSpeed.value);
  const step = 0.2; // ubah step kalau mau gerak lebih halus
  let changed = false;

  if (key === "k") {
    current = Math.max(0, current - step);
    changed = true;
  }
  if (key === "l") {
    current = Math.min(presetSpeed.max ? Number(presetSpeed.max) : 100, current + step);
    changed = true;
  }

  if (changed) {
    presetSpeed.value = current;

    // update state presetSpeed jika ada
    if (typeof state !== "undefined") state.presetSpeed = current;

    // tampilkan status
    if (typeof setStatus === "function") setStatus(`Preset Speed: ${current}`, 500);

    // kirim data / update beam realtime
    if (typeof sendData === "function") sendData();
  }
});
</script>
</script>
</body>
</html>